<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2014 | 海斯维思研发团队</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta content="website" property="og:type">
<meta content="海斯维思研发团队" property="og:title">
<meta content="http://hiservicerd.github.io/archives/2014/" property="og:url">
<meta property="og:image">
<meta content="海斯维思研发团队" property="og:site_name">
<meta property="og:description">
<meta content="summary" name="twitter:card">
  
    <link rel="alternative" href="/atom.xml" title="海斯维思研发团队" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-51090540-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">海斯维思研发团队</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">文章</a>
        
          <a class="main-nav-link" href="https://github.com/HiServiceRD">GIT</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://hiservicerd.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-google-measuring-the-critical-rendering-path-with-navigation-timing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/" class="article-date">
  <time datetime="2014-05-21T08:20:03.000Z" itemprop="datePublished">5月 21 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/">使用导航计时监测渲染关键路径</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）</p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>导航计时为监测渲染关键路径提供了高分辨率的时间戳</li>
<li>浏览器在到达渲染关键路径的不同阶段时，会触发一系列的事件</li>
</ul>
<h3 id="用于监测的时间戳">用于监测的时间戳</h3>
<p>好的性能策略都是建立在良好的测量基础之上的。下面这张图说明了导航计时接口提供的API：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/1.png" alt="导航计时接口提供的API"></p>
<p>上面的每一个标签都提供了一个方法，用于检测每一个页面加载的高分辨率的时间戳。在这里，我们仅仅介绍除了与网络相关的时间戳的哪些一部分时间戳，剩下的我们会在以后的章节作介绍</p>
<p>那么，这些时间戳代表着什么？</p>
<ul>
<li>domLoading：整个处理过程开始的时间，也就是浏览器开始解析HTML文档的第一个字节的时间</li>
<li>domInteractive：浏览器解析完所有HTML，并完成DOM构建的时间</li>
<li>domContentLoaded：开始构建渲染树的时间点，就是DOM构建完毕后，若没有样式以及阻塞的JavaScript运行的时间点<ul>
<li>许多JavaScript框架都会监听这个事件，然后执行他们自己的逻辑。因此浏览器提供了EventStart和EventEnd两个时间戳来允许我们知道具体运行消耗的时间</li>
</ul>
</li>
<li>domComplete：和名字一样，记录了页面上的所有资源都下载完成（包括图片）以及所有处理逻辑都结束后的时间点。这个时间点过后，浏览器旋转的加载标记将不再旋转了</li>
<li>loadEvent：最后，浏览器触发onload事件来执行一些其他的应用逻辑</li>
</ul>
<h3 id="里程碑">里程碑</h3>
<p>根据HTML的规范，浏览器会检测所有事件：什么时候应该触发事件，应该满足哪些条件等等。对于我们来说，我们只需要关注渲染关键路径上的一些“里程碑”事件：</p>
<ul>
<li>domIneractive：说明DOM构建完毕</li>
<li>domContentLoaded：当DOM和CSSOM都完成后触发<ul>
<li>如果没有“解析器阻塞”的JavaScript代码，documentContentLoaded将直接在domInteractive之后触发</li>
</ul>
</li>
<li>domComplete：当页面及其所有资源全部完毕时触发</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Measure<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
      <span class="function"><span class="keyword">function</span> <span class="title">measureCRP</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> t = window.performance.timing,
          interactive = t.domInteractive - t.domLoading,
          dcl = t.domContentLoadedEventStart - t.domLoading,
          complete = t.domComplete - t.domLoading;
        <span class="keyword">var</span> stats = document.createElement(<span class="string">'p'</span>);
        stats.textContent = <span class="string">'interactive: '</span> + interactive + <span class="string">'ms, '</span> +
            <span class="string">'dcl: '</span> + dcl + <span class="string">'ms, complete: '</span> + complete + <span class="string">'ms'</span>;
        document.body.appendChild(stats);
      }
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">onload</span>=<span class="value">"measureCRP()"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>上面的例子乍看之下可能比较吓人，但实际上非常简单，导航计时API捕获了相关的时间戳，而我们的JavaScript代码放在onload事件的回调函数中，只有触发了onload事件，才会执行。onload事件只有在domInteractive、domContentLoaded和domComplete事件都完成之后才会触发，所以我们可以捕获到这些时间戳之间的差值，算出每个阶段所耗费的时间</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/2.png" alt="时间戳检测结果"></p>
<p>综上所述，我们可以获得一些“里程碑事件”以及一些简单的函数来输出测量结果。当然我们可以不将这些数据输出到页面上，而是发送这些分析的数据到专门的分析服务器（Google的分析工具就会自动做这些事），这样就能很方便的检测网页的性能，确定候选页面，并尝到优化所带来的甜头。</p>

      
    </div>
    <footer class="article-footer">
      
        <a href="http://hiservicerd.github.io/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

      <div class="jiathis_style">
        <a class="jiathis_button_qzone"></a>
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_tqq"></a>
        <a class="jiathis_button_weixin"></a>
        <a class="jiathis_button_renren"></a>
        <a class="jiathis_button_xiaoyou"></a>
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <a class="jiathis_counter_style"></a>
      </div>
      <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1394026832027748" charset="utf-8"></script>
    </footer>
  </div>
  
</article>


  
    <article id="post-google-google-adding-interactivity-with-javaScript" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/21/google-google-adding-interactivity-with-javaScript/" class="article-date">
  <time datetime="2014-05-21T08:20:02.000Z" itemprop="datePublished">5月 21 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/21/google-google-adding-interactivity-with-javaScript/">通过JavaScript增加交互性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。</p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>JavaScript可以对DOM和CSSOM进行查询和修改</li>
<li>JavaScript的执行会阻塞CSSOM的构建</li>
<li>JavaScript阻塞DOM树的构建，除非显式的声明为异步</li>
</ul>
<h3 id="JavaScript造成的阻塞">JavaScript造成的阻塞</h3>
<p>JavaScript一个跑在浏览器中的动态语言，JavaScript允许我们修改页面中的每一方面：我们能够通过在DOM树上添加或删除节点来修改网页内容，也能修改元素的CSSOM属性，还能处理用户输入等等。这里提供了一个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
      <span class="keyword">var</span> span = document.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];
      span.textContent = <span class="string">'interactive'</span>; <span class="comment">// change DOM text content</span>
      span.style.display = <span class="string">'inline'</span>;  <span class="comment">// change CSSOM property</span>
      <span class="comment">// create a new element, style it, and append it to the DOM</span>
      <span class="keyword">var</span> loadTime = document.createElement(<span class="string">'div'</span>);
      loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();
      loadTime.style.color = <span class="string">'blue'</span>;
      document.body.appendChild(loadTime);
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<ul>
<li>JavaScript允许我们进入到DOM树中，甚至获取隐藏的span元素。事实上隐藏的元素并不存在于渲染树中，但它仍然存在于DOM树中。因此，当我们获取到它的引用时，我们能够修改其内部的文字（通过textContent进行修改），我们甚至能修改它的display样式值，从‘none’改到‘inline’。这上面说的都完成之后，我们的网页将会显示“Hello interative students!”</li>
<li>JavaScript也允许我们创建节点，为节点赋予样式，在DOM中添加和删除节点。事实上，在技术上，我们的整个页面可以通过一个巨大JavaScript文件来一个一个创建节点并给他们赋予样式。这同样能工作，但使用HTML和CSS明显更加简单。JavaScript函数的第二部分创建了一个div元素，并设定了文字，赋予了样式，然后将其添加到body上。</li>
</ul>
<p>这里，我们修改了已经存在DOM节点的的内容和CSS样式，并在文档中加入了一个全新的节点。JavaScript为我们的网页提供了更强的能力和灵活性。</p>
<p>然而，这里潜伏着一个大的性能问题。JavaScript为我们提供了更强的能力，但也为渲染的方式和时间带来的一定的限制。</p>
<p>首先，注意上面的例子中，我们的内联脚本放在了页面的底部。这是为什么呢？你可以自己试试，如果你将脚本移动到span元素的上面，可以看到script里面的脚本将会运行失败并报出错误说在文档中找不到任何span元素（<code>getElementsByTagName(&#39;span&#39;)</code>返回null）。这说明了很重要的一点：脚本运行的位置，是其在文档中的位置。当HTML解析器发现到了script标签时，他会暂停DOM的构建并将控制权交给JavaScript引擎。一旦JavaScript运行完毕，浏览器将会回到之前的位置，继续DOM的构建。</p>
<p>换句话说，脚本内部无法发现其后面的元素，因为他们还没有被处理过。或者再换个说法：<strong>运行内联脚本将阻塞DOM的构建，这也意味着阻塞页面初始的渲染</strong>。</p>
<p>页面中的脚本的另一个点在于：脚本不仅仅能够修改DOM，也能够修改CSSOM。事实上，上面的例子中，我们已经修改了span元素的display属性，将它从none修改到inline</p>
<p>那么，如果浏览器还没有完成CSSOM的下载和构建，就需要运行脚本，浏览器会怎么做？答案很简单，但效率不好：<strong>浏览器将延迟脚本的执行，直到CSSOM的下载和构建全部完成之后，才会执行。与此同时，在我们等待的时候，DOM构建也会阻塞。</strong></p>
<p>简而言之，JavaScript引入了很多的DOM、CSSOM之间的相互依赖，同时JavaScript的执行将会在浏览器处理和页面渲染时导致明显的时延：</p>
<ol>
<li>脚本在文档中的位置很重要</li>
<li>发现script标签时，会暂停DOM的构建，直到脚本被运行完成，DOM构建才会继续</li>
<li>JavaScript能够查询和修改DOM和CSSOM</li>
<li>JavaScript只有在CSSOM被构建完毕之后才会执行</li>
</ol>
<p>当我们谈及“渲染性能优化”，在很大程度上，我们谈及的是HTML、CSS和JavaScript之间的依赖关系图。</p>
<h3 id="解析器的阻塞和异步JavaScript">解析器的阻塞和异步JavaScript</h3>
<p>默认情况下，JavaScript的执行是“解析器阻塞”的：当浏览器在文档中遇到一个script标签时，DOM的构建会被暂停，控制权递交给JavaScript运行，DOM的构建将会在JavaScript运行完成之后继续执行。这可以从上面的内联脚本例子中看出来。事实上，内联脚本总是“解析器阻塞”的，除非特别照顾这些代码来推迟其执行。</p>
<p>那么如何通过script标签包含脚本？我们继续使用之前的的例子，将代码放在单独文件中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script External<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"app.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>




<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> span = document.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];
span.textContent = <span class="string">'interactive'</span>; <span class="comment">// 改变DOM中的文本</span>
span.style.display = <span class="string">'inline'</span>;  <span class="comment">// 改变CSSOM属性</span>
<span class="comment">// 创建一个新元素，为其添加样式，并将其加入到DOM中</span>
<span class="keyword">var</span> loadTime = document.createElement(<span class="string">'div'</span>);
loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();
loadTime.style.color = <span class="string">'blue'</span>;
document.body.appendChild(loadTime);
</pre></td></tr></table></figure>


<p>你是否认为通过<code>&lt;scirpt&gt;</code>引入的JavaScript代码和内联JavaScrip它的执行顺序不同？当然，这个答案是否定的，这两者的处理方式几样。无论是前者还是后者，浏览器都在处理后面的文档之前，暂停并执行脚本。<strong>然而：在当浏览器使用外部JavaScript文件时，也不得不暂停并等待脚本从磁盘、缓存、或陈远程服务器中获取。这可能在为页面渲染带来上千万毫秒的时延</strong></p>
<p>有一个好戏，我们确实有一个解决方法。默认情况下，所有的JavaScript都是“解析器阻塞”的，浏览器也不知道JavaScript脚本究竟会在网页山做些什么，因此它会假定最坏的情况并阻塞解析器。然而，如果我们有办法告诉浏览器我们的脚本不需要在它所处的文档位置上被执行，那会怎样呢？如果这样做，浏览器会继续DOM构建，并直到DOM构建完成后，运行脚本，无论是文件是从高速缓存直接中获取还是从远程服务器中获取。</p>
<p>那么我们怎样实现呢，我们能直接标记脚本为异步脚本：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre> <span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script Async<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"app.js"</span> <span class="attribute">async</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>增加了async属性能够高速浏览器，它不会在下载和执行过程中阻塞DOM构建。这是一个巨大的效率提升！</p>

      
    </div>
    <footer class="article-footer">
      
        <a href="http://hiservicerd.github.io/2014/05/21/google-google-adding-interactivity-with-javaScript/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

      <div class="jiathis_style">
        <a class="jiathis_button_qzone"></a>
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_tqq"></a>
        <a class="jiathis_button_weixin"></a>
        <a class="jiathis_button_renren"></a>
        <a class="jiathis_button_xiaoyou"></a>
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <a class="jiathis_counter_style"></a>
      </div>
      <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1394026832027748" charset="utf-8"></script>
    </footer>
  </div>
  
</article>


  
    <article id="post-google-render-blocking-css" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/21/google-render-blocking-css/" class="article-date">
  <time datetime="2014-05-21T08:20:01.000Z" itemprop="datePublished">5月 21 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/21/google-render-blocking-css/">CSS的渲染阻塞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>默认情况下，CSS会被看做是渲染阻塞资源，也就是说，浏览器在CSSOM建立前，已经处理过的网页内容不会被显示到页面上。所以，保证你的CSS代码能够快速从服务器获取且尽可能的简短，并注意使用媒体类型（media types）和媒体查询（media queries）去进行非阻塞的渲染。</p>
<p>在之前的章节中，我们已经知道了要建立渲染树，必须先建立好DOM树和CSSOM树，这里有一个很重要的性能要点：HTML和CSS都是渲染阻塞资源。HTML很明显，因为如果没有创建好DOM树，浏览器都不知道有什么东西需要渲染。但CSS就不那么明显了。如果我们尝试不使用CSS的阻塞渲染去渲染一个典型的页面，会发生什么呢？</p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>默认情况下CSS是渲染阻塞资源</li>
<li>媒体类型和媒体查询可以让一些CSS变成非渲染阻塞资源</li>
<li>所有CSS资源，无论是阻塞还是非阻塞，都需要通过浏览器进行下载</li>
</ul>
<h3 id="CSS是渲染阻塞资源">CSS是渲染阻塞资源</h3>
<p>浏览器将会阻塞渲染直到DOM树和CSSOM树都创建完毕</p>
<p><strong>CSS是渲染阻塞元素，尽可能快速的让浏览器下载到文件，这样可以减少阻塞的时间</strong></p>
<p>然而，如果我们有一些只有在特定条件下才使用的样式，比如打印或是在大的显示器中显示等情况，我们当然不希望这些特定条件下才会使用的样式阻塞渲染。</p>
<h3 id="媒体类型和媒体查询">媒体类型和媒体查询</h3>
<p>CSS中的媒体类型和媒体查询就可以达到这种效果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"print.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"other.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"(min-width: 40em)"</span>&gt;</span>
</pre></td></tr></table></figure>


<p>一个媒体查询可以由一个媒体类型和查询表达式构成，查询表达式可以是任意个数，他们检测了当前设备的特点。比如，在第一个样式表申明中并没有使用媒体类型和媒体查询，因此它在所有情况下都会被应用，也就是说，它总汇总阿红才呢过渲染阻塞。而另一方面，第二个样式表仅仅在网页内容被打印时才会被应用，可能你需要在打印时改换一下布局，改变一下字体等等，因此，这个样式表不会再页面首次加载时造成渲染阻塞。而最后一个样式表提供了一个媒体查询，浏览器将判断条件是否满足。如果浏览器满足媒体查询中的条件，浏览器将在下载并处理完这个样式表之前阻塞渲染。</p>
<p>通过使用媒体查询，我们可以根据特定的用例来定制展现的样式，比如显示和打印。同时，还能动态的判断诸如屏幕方向，缩放事件等等。在申明样式表时，重点关注媒体类型和媒体查询，他们将很大程度影响网页渲染的效率。</p>
<p>让我们考虑如下例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"portrait.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"orientation:portrait"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"print.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span>
</pre></td></tr></table></figure>


<ol>
<li>第一个样式申明将会造成渲染阻塞，它在任意情况下都会被应用；</li>
<li>第二个样式申明也会造成渲染阻塞：“screen”是默认类型，除非你执行了一个其他类型，否则浏览器总是显示的设定媒体类型为“screen”。因此这个样式申明和第一个样式申明等价；</li>
<li>第三个样式申明是一个动态的媒体查询，他会在页面加载完成之后进行计算。根据页面加载完成后的设备横竖屏来决定样式是否会阻塞渲染；</li>
<li>最后一个样式申明仅仅在页面被打印的时候起作用，因此他不会在页面首次加载进浏览器中时造成渲染阻塞</li>
</ol>
<h3 id="浏览器下载">浏览器下载</h3>
<p>最后，注意一下渲染阻塞只是指浏览器是否要在页面初始渲染时，是否需要渲染该资源内部的样式。无论在何种情况下，尽管非阻塞资源的优先级较低，CSS文件依旧必须要由浏览器进行下载。</p>

      
    </div>
    <footer class="article-footer">
      
        <a href="http://hiservicerd.github.io/2014/05/21/google-render-blocking-css/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/">HTML</a></li></ul>

      <div class="jiathis_style">
        <a class="jiathis_button_qzone"></a>
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_tqq"></a>
        <a class="jiathis_button_weixin"></a>
        <a class="jiathis_button_renren"></a>
        <a class="jiathis_button_xiaoyou"></a>
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <a class="jiathis_counter_style"></a>
      </div>
      <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1394026832027748" charset="utf-8"></script>
    </footer>
  </div>
  
</article>


  
    <article id="post-google-render-tree-construction-layout-and-paint" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/20/google-render-tree-construction-layout-and-paint/" class="article-date">
  <time datetime="2014-05-20T08:20:01.000Z" itemprop="datePublished">5月 20 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/20/google-render-tree-construction-layout-and-paint/">渲染树的构建，布局和绘制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要介绍了渲染树的构建、布局阶段和绘制阶段，翻译自<a href="desc: 本文主要介绍了渲染树的构建、布局阶段和绘制阶段，翻译自&lt;a href=&#39;https://developers.google.com/web/fundamentals/documentation/performance/critical-rendering-path/constructing-the-object-model">Google Web Fundamentals</a></p>
<p>CSSOM树和DOM树组合生成渲染树，渲染树将决定每一个可见元素的计算样式，并作为输入交给绘制线程，绘制线程将会把他们渲染成像素打到屏幕上。优化这些步骤将是提升渲染性能的关键所在。</p>
<p>上一章节介绍了如何构建对象模型。我们从HTML和CSS构建出了DOM树和CSSOM树。但是，他们描述的是文档的不同方面：DOM树描述的是页面内容，而CSSOM树则描述的是需要被使用到页面内容上的样式规则，由此可见，他们是相互独立的数据结构。那么我们应当如何去合并这两棵树来让浏览器渲染像素到屏幕呢？</p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>DOM树和CSSOM树结合组成了渲染树</li>
<li>渲染树（Render tree）只会包含需要绘制到页面上的节点</li>
<li>布局（Layout）会计算出每一个对象的具体位置和大小</li>
<li>绘制（Paint）是最后异步，将会将渲染树渲染成像素，显示到屏幕上</li>
</ul>
<h3 id="构建渲染树">构建渲染树</h3>
<p>浏览器首先需要结合DOM树和CSSOM树到渲染树，渲染树获取所有页面上可见的DOM内容，再吧CSSOM中的样式信息附着到每一个节点上</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/7.png" alt="组合DOM树和CSSOM树，生成渲染树"></p>
<p>为了构建渲染树，浏览器所做的工作大致如下：</p>
<ol>
<li>从DOM树的根节点开始，遍历每个可见的节点<ul>
<li>有些节点本身不可见（比如script、meta等等）</li>
<li>有些节点被CSS隐藏了，这些节点也会被渲染树忽略</li>
</ul>
</li>
<li>对于每一个可见节点，会从CSSOM中找并应用到其对应的样式信息</li>
<li>提交可见的节点和他们的内容和样式</li>
</ol>
<p><strong>需要注意的是，<code>visibility:hidden</code>和<code>display:none</code>是不同的。前者会将元素隐藏，但元素依旧在页面中占据空间（会被绘制成空的盒子），所以需要递交给布局阶段进行处理。而后者会从渲染树中移除元素及所有子元素，他们被递交给布局阶段</strong></p>
<p>这个阶段完毕后，会生成一个包含所有可见节点的内容和样式信息的渲染树。接下来可以进行布局阶段了</p>
<h3 id="布局阶段">布局阶段</h3>
<p>目前为止，我们已经获取了可见节点的计算样式，但我们还没有计算元素在设备视口中的最终的位置和尺寸——计算这些就是布局阶段的工作，它还有另外一个我们熟知的名称：回流（reflow）</p>
<p>为了计算每个节点的最终位置和尺寸，需要从根节点开始遍历渲染树，计算渲染树中每个对象在页面上的几何图形。比如如下例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critial Path: Hello world!<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"width: 50%"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"width: 50%"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>上面的页面的body元素包含两个嵌套的div，第一个div（父元素）其节点的宽度为视口宽度的50%，第二个div在第一个div之中，宽度是第一个元素的50%，也就是视口宽的的50%。</p>
<p>布局阶段输出的是一个盒子模型，它精确地描述了元素在视口中的确切位置和尺寸：所有相对单位都会被转变为屏幕上的绝对像素值，等等</p>
<p>现在我们知道了哪些元素可见，他们的计算样式，以及他们的几何图形，我们终于能够将这些信息传递给最终阶段。这个阶段将渲染树中的每个节点绘制成屏幕上像素。通常这个阶段叫做绘制阶段（painting）或是光栅化（rasterizing）</p>
<h3 id="绘制阶段">绘制阶段</h3>
<p>这里面每个步骤都需要浏览器惊醒一定量的工作，也就说会花费一定的时间。我们可以通过Chrome开发者工具看我们上面所说到的三个阶段。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/8.png" alt="开发者工具中查看布局阶段"></p>
<ul>
<li>Timeline中的Layout事件包含渲染树的构建阶段和位置尺寸的计算阶段</li>
<li>一旦布局阶段完成，浏览器会开启“Paint Setup”和“Paint”事件，用来将渲染树转变成屏幕上的像素</li>
</ul>
<p>上面所说的渲染树构建、布局阶段、绘制阶段所需要的事件会根据文档的大小、样式的多少、设备的配置有关。文档越大，浏览器需要做更多的工作。样式越复杂，浏览器需要考虑更多的绘制（绘制一个固定颜色代价很低，但绘制一个阴影代价很大）。</p>
<p>这些都完成后，我们的页面终于展示在视口里了</p>
<h3 id="总结">总结</h3>
<p>我们来重温一下所有的步骤：</p>
<ol>
<li>处理HTML标记，构建DOM树</li>
<li>处理CSS标记，构建CSSOM树</li>
<li>合并DOM树和CSSOM树，构建渲染树</li>
<li>在渲染树上运行布局阶段，计算每个可见节点的几何图形</li>
<li>绘制每个独立的节点到屏幕上</li>
</ol>
<p>考虑如果DOM或CSSOM发生改变时，会发生些什么？我们需要重复这些工作来确定如何回执到屏幕上</p>
<p>优化渲染的关键就是减少这5步所花费的时间。减少这5步所花费的事件能够让页面尽可能快的展示到页面上。在首次页面渲染之后，每次更新后的渲染效率也会提高。</p>

      
    </div>
    <footer class="article-footer">
      
        <a href="http://hiservicerd.github.io/2014/05/20/google-render-tree-construction-layout-and-paint/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/">HTML</a></li></ul>

      <div class="jiathis_style">
        <a class="jiathis_button_qzone"></a>
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_tqq"></a>
        <a class="jiathis_button_weixin"></a>
        <a class="jiathis_button_renren"></a>
        <a class="jiathis_button_xiaoyou"></a>
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <a class="jiathis_counter_style"></a>
      </div>
      <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1394026832027748" charset="utf-8"></script>
    </footer>
  </div>
  
</article>


  
    <article id="post-google-constructing-the-object-model" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/20/google-constructing-the-object-model/" class="article-date">
  <time datetime="2014-05-20T08:20:00.000Z" itemprop="datePublished">5月 20 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/20/google-constructing-the-object-model/">构建对象模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要介绍了DOM和CSSOM的构建过程，翻译自<a href="https://developers.google.com/web/fundamentals/documentation/performance/critical-rendering-path/constructing-the-object-model" target="_blank">Google Web Fundamentals</a></p>
<p>浏览器渲染页面之前会构建DOM树和CSSOM树</p>
<h2 id="长话短说">长话短说</h2>
<ul>
<li>字节(bytes) → 字符(characters) → 标记(tokens) → 节点(nodes) → 对象模型(object model)</li>
<li>HTML标记将会被转化为一个文档对象模型（Document Object<code>enter code here</code> Module，以下简称DOM），而CSS标记将会被转化成一个CSS对象模型（CSSOM）</li>
<li>DOM和CSSOM是互相独立的数据结构</li>
<li>Chrome的开发者工具的Timeline里面可以捕捉到DOM和CSSOM的构建和处理</li>
</ul>
<h2 id="DOM树构建">DOM树构建</h2>
<p>比如一段如下HTML</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>其从字节到DOM树的过程如下图所示：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/1.png" alt="从字节到DOM树的过程"></p>
<p>具体的过程分为如下几步：</p>
<ol>
<li>转换（Conversion）：浏览器从网络或硬盘中读取原始的字节，并根据其编码方式转换为独立的字符</li>
<li>标记化（Tokenizing）：浏览器根据W3C的html5标准解析出尖括号内的字符串，每一个标记有自己的意义和规则</li>
<li>对象化（Lexing）：将标记转变为对象，对象内定义了他们的值和规则</li>
<li>DOM构建（DOM construction）：由于HTML标记定义了节点之间的关系，且这个关系是树型结构的（某个节点包含多个节点），所以通过一个树来保存</li>
</ol>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/2.png" alt="DOM树的树状结构"></p>
<p>整个过程输出的是一个DOM，它是网页的DOM树，后面的处理都会用到DOM树</p>
<p>每一次浏览器要讲HTML标记转换成DOM树，都需要经过这些过程：从字节转换到字符，获取其中的标记，转换标记到节点，通过节点构建DOM树，这些过程需要消耗一定的时间</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/3.png" alt="Chrome DevTools中的DOM树构建过程"></p>
<p>如果打开Chrome开发者工具，并在页面加载时记录Timeline，你讲看到这些步骤的具体时间。在上例中，浏览器花费了约5ms将一个HTML碎片从字节转换到DOM树，当然，如果页面较大，这个时间会更长。在接下来的创建流畅动画的章节中，如果浏览器需要处理大量的HTML，这里很容易成为瓶颈。</p>
<p>DOM树构建好后，我们还需要将其渲染到屏幕上。DOM树中并没有告诉浏览器应该如何渲染这些节点，而完成这个职责的就是下面的CSSOM树了</p>
<h2 id="CSSOM树构建">CSSOM树构建</h2>
<p>当浏览器为页面构建DOM树的时候，它会统计head部分的link标签，指向外部CSS样式文件。浏览器需要这些文件来渲染页面，它会直接发送请求来获取文件</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">body</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">16</span>px </span></span></span>}
<span class="tag">p</span> <span class="rules">{ <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold </span></span></span>}
<span class="tag">span</span> <span class="rules">{ <span class="rule"><span class="attribute">color</span>:<span class="value"> red </span></span></span>}
<span class="tag">p</span> <span class="tag">span</span> <span class="rules">{ <span class="rule"><span class="attribute">display</span>:<span class="value"> none </span></span></span>}
<span class="tag">img</span> <span class="rules">{ <span class="rule"><span class="attribute">float</span>:<span class="value"> right </span></span></span>}
</pre></td></tr></table></figure>


<p>当然我们也可以在HTML标记中声明CSS样式（内联样式），但保持CSS和HTML的独立使得我们能够将设计与内容分离：设计者基于CSS工作，而开发者则专注于HTML，等等</p>
<p>和HTML一样，我们将CSS样式转换到某种浏览器能够理解且使用的结构。其大致过程如下：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/4.png" alt="浏览器将CSS字节转换到CSSOM"></p>
<p>浏览器将CSS字节转换成字符，然后构建标记和节点，最后练级到一个叫做CSS对象模型（CSSOM）的树型数据结构</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/5.png" alt="树状CSSOM"></p>
<p>HTML是树状结构很好理解，那么为什么CSSOM也是树状结构呢？在计算页面上对象的需要使用的样式集时，浏览器首先将最常规的样式赋给节点（如果是body元素的孩子，那么会使用body的所有样式），然后递归细化，逐步添加上特殊的规则，这也就是级联样式表中“级联”的意思</p>
<p>上面的树并不是完整的CSSOM树，目前只是展示了样式表中的样式如何互相覆盖。么一个浏览器都提供了一套自己的样式，也就是“用户代理样式（user agent styles）”，在我们不提供任何样式的时候，就会使用这些央视。如果在Chrome开发者工具里面查看“计算后样式（computed styles）”，可以看到所有节点中样式的来源</p>
<p>如果想知道CSS处理花费多长时间，可以在开发者工具中记录Timeline，并查看“Resalcuate”事件：与DOM解析不同的是，这里不会分开的“Parse CSS”各个阶段，解析、CSSOM树构建以及样式的递归计算都放在这一个事件之中</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/6.png" alt="通过开发者工具查看样式处理"></p>
<p>这里可以看到，这次样式处理花费了约0.6ms，涉及页面上的8个元素。那这8个元素从哪儿来？CSSOM和DOM是完全独立的数据结构，浏览器隐藏了很重要的一步，通过渲染树（render tree）将CSSOM和DOM连接起来，下一章就将介绍这个渲染树</p>

      
    </div>
    <footer class="article-footer">
      
        <a href="http://hiservicerd.github.io/2014/05/20/google-constructing-the-object-model/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/">HTML</a></li></ul>

      <div class="jiathis_style">
        <a class="jiathis_button_qzone"></a>
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_tqq"></a>
        <a class="jiathis_button_weixin"></a>
        <a class="jiathis_button_renren"></a>
        <a class="jiathis_button_xiaoyou"></a>
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <a class="jiathis_counter_style"></a>
      </div>
      <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1394026832027748" charset="utf-8"></script>
    </footer>
  </div>
  
</article>


  
    <article id="post-google-responsive-design-fundamentals" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/19/google-responsive-design-fundamentals/" class="article-date">
  <time datetime="2014-05-19T08:31:00.000Z" itemprop="datePublished">5月 19 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/19/google-responsive-design-fundamentals/">响应式Web设计基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文所有内容来自<a href="https://developers.google.com/web/fundamentals/documentation/multi-device-layouts/rwd-fundamentals/" target="_blank">Responsive Web Design Fundamentals</a></p>
<p>手机、大屏手机、平板电脑、桌面电脑、游戏控制台、电视、甚至是可穿戴设备，如此多的设备也形成了多种多样的屏幕尺寸。屏幕的大小总在变，我们需要我们的网页今后能够适应任何屏幕尺寸</p>
<p>响应式Web设计，最初的定义（<a href="http://alistapart.com/article/responsive-web-design/" target="_blank">Ethan Marcotte in A List Apart</a>）是让网页响应用户及其所用设备的需求。在响应式设计中，布局将会随着设备的屏幕尺寸和显示能力而改变。比如，在手机上，用户只看到包含内容的单列视图，而在平板电脑中则能看到两列</p>
<h2 id="设置视口信息">设置视口信息</h2>
<p>网页若需要适配不同的设备，在其文档的head元素中，需要包含一个meta元素，这个meta元素视口控制信息。这个meta元素告诉浏览器如何控制页面的尺寸缩放</p>
<h3 id="长话短说">长话短说</h3>
<ol>
<li>使用meta元素，里面包含视口控制信息去控制浏览器视口的宽度和缩放</li>
<li>写入<code>width=device-width</code>去使用设备的像素去匹配屏幕的宽度</li>
<li>写入<code>initial-scale=1</code>去建立CSS像素与设备像素的1:1对等关系</li>
<li>保证你的页面在用户缩放的时候依旧可用</li>
</ol>
<h3 id="最佳实践">最佳实践</h3>
<p>为了提供最佳的用户体验，手机浏览器一般以980px（这个值会可能在不同设备中略有不同）的宽度渲染页面，然后会尝试去减少文字大小以及缩放内容到屏幕大小来让内容看起来更加适于阅读。对于用户来说，这也意味着字体的大小可能会不一致，用户需要通过双击或手势缩放来放大网页，这样才能看到内容并与之交互</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width, initial-scale=1.0"</span>&gt;</span>
</pre></td></tr></table></figure>


<p>我们可以使用meta标签来指定viewport信息，这里<code>width=device-width</code>表明页面将会以设备的像素大小来适配屏幕宽度。这样无论是在小屏幕手机上还是大屏幕显示器上，页面都可以为不同的屏幕尺寸进行内容的回流</p>
<p>有一些浏览器会在横竖屏切换时保持页面宽度不变，他们仅仅会进行缩放，而不会让内容回流来适应屏幕。增加属性<code>initial-scale=1</code>告诉浏览器去建立CSS像素和设备像素的1:1对等关系，而无视设备的方向，这样网页就能适应横竖屏的宽度变化了</p>
<p><strong>使用一个逗号去区分属性保持老式浏览器也能获取到值</strong></p>
<h3 id="确定一个可访问的视口">确定一个可访问的视口</h3>
<p>除了使用<code>initial-scale</code>，也可以在视口控制信息中加入<code>minimum-scale</code>,<code>maximum-scale</code>和<code>user-scalable</code>等属性。这些值将限制用户缩放视口的比例，可能会降低网页的可访问性</p>
<h2 id="使得内容适配视口">使得内容适配视口</h2>
<p>无论是手机还是桌面电脑，用户通常是垂直滚动页。也就是说，强迫用户水平滚动页面或者必须缩放才能看到整个页面，都会降低用户体验</p>
<h3 id="长话短说-1">长话短说</h3>
<ol>
<li>不要为元素设定大且固定的尺寸</li>
<li>内容的展现不应该依赖于一个特定的视口宽度</li>
<li>使用CSS的媒体查询来为不同的屏幕尺寸提供不同的样式</li>
</ol>
<h3 id="最佳实践-1">最佳实践</h3>
<p>在开发手机网页中使用<code>meta viewport</code>元素进行开发时，很容易导致页面内容无法匹配某些特定的视口。比如，一张图片能够在较宽呃视口中完全显示，但在较窄的视口中则必须要水平滚动才能看到右边的部分。我们需要调整页面内容来适应视口的宽度，这样它们就不需要水平滚动了</p>
<p>由于不同设备基于CSS像素的尺寸和宽度不同（手机和平板之间不同，甚至不同的手机之间也不同），所以页面内容不能只依赖于一个特定的视口宽度。</p>
<p>如果元素设定了较大的绝对宽度，元素在窄设备中将由于太宽而只能显示一部分。取而代之，考虑使用相对宽度（如<code>width: 100%</code>）</p>
<h2 id="为响应式使用CSS的媒体查询">为响应式使用CSS的媒体查询</h2>
<p>媒体查询其实能在CSS样式中使用的过滤器，他们能够很轻易的根据设备的特点来改变渲染网页内容的CSS样式，这些特点包括设备的显示类型，宽高，横竖屏甚至是分辨率</p>
<h3 id="长话短说-2">长话短说</h3>
<ol>
<li>媒体查询可以根据设备特点来应用样式</li>
<li>使用<code>min-width</code>而不是<code>min-device-width</code>来保证更多情况下能有好的体验</li>
<li>为元素使用相对大小防止破坏布局</li>
</ol>
<h3 id="最佳实践-2">最佳实践</h3>
<p>比如，我们可以通过这样的方式加入打印时需要的样式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"print.css"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span>
</pre></td></tr></table></figure>


<p>除了在样式的link元素中增加<code>media</code>属性，还有两种其他方法在CSS文件在中使用媒体查询：<code>@media</code>和<code>@import</code>。处于效率考虑，推荐使用前两种方式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">media</span> print </span>{
  <span class="comment">/* print style sheets go here */</span>
}

<span class="at_rule">@<span class="keyword">import</span> <span class="function">url(print.css)</span> print</span>;
</pre></td></tr></table></figure>


<p>媒体查询中的逻辑不会互相冲突，并且符合媒体查询条件而引入的CSS样式也会根据CSS优先级标准作用与页面中</p>
<h3 id="根据视口大小使用媒体查询">根据视口大小使用媒体查询</h3>
<p>媒体查询为创建响应式的体验成为可能，通过媒体查询，我们能为小屏幕，大屏幕，或者两者之间来提供特定的样式表。媒体查询的语法允许我们根据设备的特点来创建匹配规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">media</span> (query) </span>{
  <span class="comment">/* CSS Rules used when query matches */</span>
}
</pre></td></tr></table></figure>


<p>媒体查询提供了很多查询条件供我们使用，其中我们在响应式web设计中用的最多是<code>min-width</code>、<code>max-width</code>、<code>min-height</code>、<code>max-height</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:right">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">min-width</td>
<td style="text-align:right">匹配所有宽度大于设定值的浏览器</td>
</tr>
<tr>
<td style="text-align:left">max-width</td>
<td style="text-align:right">匹配所有宽度小于设定值的浏览器</td>
</tr>
<tr>
<td style="text-align:left">min-height</td>
<td style="text-align:right">匹配所有高度大于设定值的浏览器</td>
</tr>
<tr>
<td style="text-align:left">max-height</td>
<td style="text-align:right">匹配所有高度小于设定值的浏览器</td>
</tr>
<tr>
<td style="text-align:left">orientation=portrait</td>
<td style="text-align:right">匹配竖屏，也就是高度大于或等于宽度</td>
</tr>
<tr>
<td style="text-align:left">orientation=landscape</td>
<td style="text-align:right">匹配横屏，也就是宽度大于或等于高度</td>
</tr>
</tbody>
</table>
<h3 id="关于min-device-width">关于min-device-width</h3>
<p>除了<code>*-width</code>，我们也可以在媒体查询中使用<code>*-device-width</code>，这两者有微妙且重要的差异。<code>min-width</code>检测的是浏览器的窗口的尺寸，而<code>min-device-width</code>检测的则是屏幕的尺寸</p>
<p>在手机上，这个差异一般不会有什么影响，毕竟用户不能自由调整窗口的尺寸。但在桌面上，用户能够自由控制窗口尺寸并希望网页内容能够很自然的适应窗口，所以，应当尽量避免使用<code>*-device-width</code>，否则网页将无法响应桌面浏览器窗口的缩放</p>
<h3 id="使用相对单位">使用相对单位</h3>
<p>响应式设计的一个关键概念就是流动性和比例性，而不是使用固定宽度进行布局。计量时使用相对单位能够简化布局，并防止出现创建的组件对于视口过大的情况。</p>
<p>比如，将顶层宽度设为100%，使其宽度撑开到整个视口大小，它的宽度永远不会大于或小于视口大小。这个div无论在iPhone的320px、黑莓Z10的342px还是Nexus 5的360px下，都能横向填满屏幕</p>
<p>另外使用相对单位允许浏览器在用户缩放网页时重新渲染整个页面，而不会增加一个水平滚动条。</p>
<h2 id="如何选择断点">如何选择断点</h2>
<p>尽管哦我们可以考虑基于设备类型来定义断点，但需要谨慎使用这种方式。基于特定的的设备、产品、品牌名称或操作系统定义断点，就算今天能正常使用，以后也会出现维护上的噩梦。取而代之的是，网页内容应该根据其自身来决定如何在容器中进行布局。</p>
<h3 id="长话短说-3">长话短说</h3>
<ol>
<li>基于网页内容创建断点，永远不要基于特定的设备、产品或品牌</li>
<li>以移动先行的思想设计网页，然后随着屏幕可用大小增加而渐进增强用户体验</li>
<li>保持每一行文字的最大宽度在70到80个字符左右</li>
</ol>
<h3 id="从小到大来挑选主要断点">从小到大来挑选主要断点</h3>
<p>首先，在较小的屏幕尺寸上设计网页，然后主键扩大屏幕大小直到必须要增加断点。这样断点的选取是基于网页内容，并且断点会尽可能的少。</p>
<h3 id="必要时添加次要断点">必要时添加次要断点</h3>
<p>除了显著影响布局的主要断点外，用于小范围调整的次要断点也非常有用。比如在主要断点中间，增加一些次要断点来调整元素的margin或padding，或者增加文本大小让他们在布局中显得更加自然</p>
<h3 id="优化文本阅读">优化文本阅读</h3>
<p>传荣的可读性理论建议一个理想的列每一行应该包含70到80个字符(8~10个英文单词)，也就是说，每当一行单词数量增加到10个时，我们就应该就应该加一个断点了</p>
<h3 id="不要完全隐藏内容">不要完全隐藏内容</h3>
<p>当需要根据屏幕大小选择行的显示内容时，需要注意。不要简单的由于其无法适应屏幕就将其隐藏。屏幕的大小并不能说明用户想要什么。比如，在天气预报中移除了花粉浓度对于一个不外出或没有花粉过敏症呃人来说可能没什么，但对于患有花粉过敏症的人来说就很致命了</p>

      
    </div>
    <footer class="article-footer">
      
        <a href="http://hiservicerd.github.io/2014/05/19/google-responsive-design-fundamentals/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/响应式/">响应式</a></li></ul>

      <div class="jiathis_style">
        <a class="jiathis_button_qzone"></a>
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_tqq"></a>
        <a class="jiathis_button_weixin"></a>
        <a class="jiathis_button_renren"></a>
        <a class="jiathis_button_xiaoyou"></a>
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <a class="jiathis_counter_style"></a>
      </div>
      <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1394026832027748" charset="utf-8"></script>
    </footer>
  </div>
  
</article>


  
    <article id="post-jquery-source-promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/17/jquery-source-promise/" class="article-date">
  <time datetime="2014-05-17T07:23:00.000Z" itemprop="datePublished">5月 17 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/17/jquery-source-promise/">jQuery中的异步控制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/img/jquery-source-promise/jQuery.jpg" alt="Write less, do more."></p>
<h2 id="简介">简介</h2>
<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>
<h2 id="jQuery-Callbacks">jQuery.Callbacks</h2>
<p>这是回调函数列表的构造器，内部使用一个数组来保存回调函数列表，并提供一系列的方法来维护这个列表。另外这个列表还有一些状态</p>
<h3 id="配置选项">配置选项</h3>
<p>创建一个回调函数列表可能会用到如下参数：</p>
<ol>
<li>options：一个选项类表，确定了回调函数列表如何工作，以及一些常见配置</li>
<li>once：默认情况下回调函数列表的执行时没有次数限制的，但如果设置了once，将设置回调函数列表只会被执行一次</li>
<li>memory：决定了在回调函数列表在执行过程中，是否会保留上一个函数执行的结果</li>
<li>unique：决定了回调函数列表中的函数能否重复</li>
<li>stopOnFalse：决定了在一个回调函数返回false后，后面的回调函数将不会被执行</li>
</ol>
<p>接下来看看构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>options = <span class="keyword">typeof</span> options === <span class="string">"string"</span> ?
    ( optionsCache[ options ] || createOptions( options ) ) :
    jQuery.extend( {}, options );
</pre></td></tr></table></figure>


<p>options可以是字符串，如<code>&quot;once memory&quot;</code>，如果是字符串，就先进行解析并缓存。如果options是对象，那么直接options就是这个对象</p>
<h3 id="私有变量">私有变量</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">var</span> <span class="comment">// Last fire value (for non-forgettable lists)</span>
    <span class="comment">/*用于存放运行结果*/</span>
    memory,
    <span class="comment">/*标志所有回调函数列表是否被触发过*/</span>
    fired,
    <span class="comment">/*标志当前正在执行回调函数列表中的函数*/</span>
    firing,
    <span class="comment">/*第一个被执行的回调函数*/</span>
    firingStart,
    <span class="comment">/*回调函数列表的长度*/</span>
    firingLength,
    <span class="comment">/*当前执行的回调函数在回调函数列表中的下标，如果移除了回调函数，将会对其进行修改*/</span>
    firingIndex,
    <span class="comment">/*保存回调函数的列表*/</span>
    list = [],
    <span class="comment">/*如果回调函数列表时多次执行的，那么在运行回调函数列表的过程中，可能会再次触发，这时候就需要一个队列进行等待了*/</span>
    stack = !options.once && [],
</pre></td></tr></table></figure>


<p>这里面都是一些私有变量，没啥太多好说的，官方代码里也对每个变量都写了注释</p>
<h3 id="触发函数fire">触发函数fire</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre>fire = <span class="function"><span class="keyword">function</span><span class="params">( data )</span> {</span>
    <span class="comment">/*如果使用了memory配置，data会先被保存在memory中*/</span>
    memory = options.memory && data;
    <span class="comment">/*表明这个回调函数列表已经被触发过了*/</span>
    fired = <span class="literal">true</span>;
    <span class="comment">/*确定当前执行的回调函数在回调函数列表中的位置*/</span>
    firingIndex = firingStart || <span class="number">0</span>;
    <span class="comment">/*将起始设为0*/</span>
    firingStart = <span class="number">0</span>;
    <span class="comment">/*获取回调函数列表的总长度*/</span>
    firingLength = list.length;
    <span class="comment">/*修改状态为正在执行*/</span>
    firing = <span class="literal">true</span>;
    <span class="comment">/*依次执行回调函数*/</span>
    <span class="keyword">for</span> ( ; list && firingIndex &lt; firingLength; firingIndex++ ) {
        <span class="comment">/*如果回调函数返回值是false且设定了stopOnFalse，那么执行结束，memory清空*/</span>
        <span class="keyword">if</span> ( list[ firingIndex ].apply( data[ <span class="number">0</span> ], data[ <span class="number">1</span> ] ) === <span class="literal">false</span> && options.stopOnFalse ) {
            memory = <span class="literal">false</span>; <span class="comment">// To prevent further calls using add</span>
            <span class="keyword">break</span>;
        }
    }
    <span class="comment">/*修改正在执行状态为false*/</span>
    firing = <span class="literal">false</span>;
    
    <span class="comment">/*如果等待队列中有数据，那么需要获取等待队列中的数据，再次执行回调函数列表*/</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">/*多次执行的话，stack是个数组*/</span>
        <span class="keyword">if</span> ( stack ) {
            <span class="comment">/*从等待队列中弹出数据再次执行*/</span>
            <span class="keyword">if</span> ( stack.length ) {
                fire( stack.shift() );
            }
        <span class="comment">/*如果是单次执行，且所有函数正常执行完成，缓存了最终结果，清空回调函数列表*/</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) {
            list = [];
        <span class="comment">/*否则说明函数没有正常执行完成，将回调函数列表设为无效*/</span>
        } <span class="keyword">else</span> {
            self.disable();
        }
    }
},
</pre></td></tr></table></figure>


<p>这里可以看到触发回调函数列表的逻辑。触发后，会依次执行列表中的回调函数，这里执行时有一个stopOnFalse设置，如果函数返回false，那么就终止执行。另外在执行过程中，如果又有新的执行请求到来，需要将执行请求放入等待队列之中，等待当前执行中的所有回调函数完成之后再重新执行。当然这个设定对once类型的回调函数列表不起作用</p>
<h3 id="实例">实例</h3>
<p>接下来创建了一个self对象，并进行了返回，这是个一个构造函数，说明self是真正返回的实例。看看实例中有哪些方法：</p>
<h4 id="add">add</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre>add: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">//首先保存当前列表长度</span>
        <span class="keyword">var</span> start = list.length;
        <span class="comment">/*使用jQuery.each方法遍历深度遍历arguments：
        1. 如果键值对中值为函数，那么直接添加，需要注意的是如果有unique选项，在添加前需要判重
        2. 如果值为对象那么遍历这个对象进行添加 */</span>
        (<span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">( args )</span> {</span>
            jQuery.each( args, <span class="function"><span class="keyword">function</span><span class="params">( _, arg )</span> {</span>
                <span class="keyword">var</span> type = jQuery.type( arg );
                <span class="keyword">if</span> ( type === <span class="string">"function"</span> ) {
                    <span class="keyword">if</span> ( !options.unique || !self.has( arg ) ) {
                    list.push( arg );
                    }
                } <span class="keyword">else</span> <span class="keyword">if</span> ( arg && arg.length && type !== <span class="string">"string"</span> ) {
                    <span class="comment">// Inspect recursively</span>
                    add( arg );
                }
            });
        })( <span class="built_in">arguments</span> );
        <span class="comment">/*如果正在执行回调函数列表，那么需要维护一下长度*/</span>
        <span class="keyword">if</span> ( firing ) {
            firingLength = list.length;
        <span class="comment">/*如果memory中已经有值，执行所有新增加的回调函数*/</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) {
            firingStart = start;
            fire( memory );
        }
    }
    <span class="comment">/*返回this方便链式操作*/</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>这个方法往回调函数列表中添加新函数，jQuery会非常智能的使用each对参数进行深度遍历来添加所有函数。需要注意的是，如果回调函数列表正在执行，添加之后需要维护长度。另外如果memory中有数据，我们就应该立即执行新添加的回调函数</p>
<h4 id="remove">remove</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>remove: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">/*遍历arguments，对每个函数分执行删除操作*/</span>
        jQuery.each( <span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span><span class="params">( _, arg )</span> {</span>
            <span class="keyword">var</span> index;
            <span class="comment">/*通过jQuery.inArray获取函数在回调函数列表中的位置*/</span>
            <span class="keyword">while</span> ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -<span class="number">1</span> ) {
                <span class="comment">/*删除掉这个函数*/</span>
                list.splice( index, <span class="number">1</span> );
                <span class="comment">/*如果正在执行回调函数，需要维护长度和当前正在执行的回调函数的下标*/</span>
                <span class="keyword">if</span> ( firing ) {
                    <span class="keyword">if</span> ( index &lt;= firingLength ) {
                        firingLength--;
                    }
                    <span class="keyword">if</span> ( index &lt;= firingIndex ) {
                        firingIndex--;
                    }
                }
            }
        });
    }
    <span class="comment">/*返回this方便链式操作*/</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>这里同样使用<code>jQuery.each</code>遍历所有参数，获取其中的函数，通过inArray判定，然后通过splice移除。这里需要注意的是，在回调函数列表正在执行时，删除操作同样需要维护长度，另外还可能需要维护当前正在运行的函数的下标</p>
<h4 id="has_(fn)">has (fn)</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>has: <span class="function"><span class="keyword">function</span><span class="params">( fn )</span> {</span>
    <span class="keyword">return</span> fn ? jQuery.inArray( fn, list ) &gt; -<span class="number">1</span> : !!( list && list.length );
},
</pre></td></tr></table></figure>


<p>判断一个函数是否在回调函数列表中，分判断函数和判断列表两种情况：</p>
<ol>
<li>若有fn，直接用inArray判定</li>
<li>若无fn，直接判断列表是否有长度不为0的list列表</li>
</ol>
<h4 id="empty">empty</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>empty: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    list = [];
    firingLength = <span class="number">0</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>清空回调函数列表，没啥好说的…list社为空数组，长度设为0</p>
<h4 id="disable和disabled">disable和disabled</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>disabled: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    list = stack = memory = <span class="literal">undefined</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
disabled: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !list;
},
</pre></td></tr></table></figure>


<p>将回调函数列表设定为无效，实际上就是将list，stack，memory设成undefined，检测无效也很简单，直接通过list判断，没设定无效情况下，list都是数组，其必然是真值</p>
<h4 id="lock和locked">lock和locked</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>lock: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    stack = <span class="literal">undefined</span>;
    <span class="keyword">if</span> ( !memory ) {
        self.disable();
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
locked: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !stack;
},
</pre></td></tr></table></figure>


<p>lock和locked故名思意就是将回调函数列表锁住，其判定方式是stack是否存在，在once设置下，stack本来就不存在，直接就是locked。而非once情况下，lock函数会设定stack为undefined，这样就无法在回调函数运行时进行fire了，就算锁住了。另外，如果没有memory，说明回调函数执行失败了，直接disbale掉就好</p>
<h4 id="fireWith和fire">fireWith和fire</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>fireWith: <span class="function"><span class="keyword">function</span><span class="params">( context, args )</span> {</span>
    <span class="comment">/*如果回调函数列表还有效，没触发过或者可以多次触发，那么就满足触发条件了*/</span>
    <span class="keyword">if</span> ( list && ( !fired || stack ) ) {
        args = args || [];
        args = [ context, args.slice ? args.slice() : args ];
        <span class="comment">/*如果正在出发，就放到等待队列中*/</span>
        <span class="comment">/*如果once且触发过或正在触发，可以从私有方法fire中看到，fired是在方法一开始被设置的，所以无法通过上面的fired条件，能到这里必然是没有触发或多次触发的情况。而没有触发不存在firing状态，也就不需要检测stack了*/</span>
        <span class="keyword">if</span> ( firing ) {
            stack.push( args );
        <span class="comment">/*否则直接触发*/</span>
        } <span class="keyword">else</span> {
            fire( args );
        }
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
fire: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    self.fireWith( <span class="keyword">this</span>, <span class="built_in">arguments</span> );
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
fired: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !!fired;
}
</pre></td></tr></table></figure>


<p>这里fire实际上使用fireWith实现的，我们只需要看fireWith就好。这里fireWith将触发回调函数列表的执行，触发条件是：当前回调函数列表有效，且没触发过或可以多次触发（stack存在就是可以多次触发），需要注意的是，如果正在触发，也就是firing状态时，触发请求将会被放入stack中等待</p>
<p>fired没啥好说的，判断回调函数列表是否被触发过</p>
<h3 id="小结">小结</h3>
<p>这个<code>jQuery.Callbacks</code>本质上就是维护一个数组，这个数组中都是函数。一个特点就是可以通过fire方式去挨个执行这些函数，并提供了一些配置来确定执行的过程以及执行的次数。每个Deferred对象将拥有三个Callbacks实例</p>
<h2 id="Deferred">Deferred</h2>
<p>jQuery的异步控制使用Deferred/Promise，每一个Deferred对象对应一个Promise对象，首先来看看其构造函数</p>
<h3 id="构造函数">构造函数</h3>
<h4 id="三个状态，三个操作，三个列表">三个状态，三个操作，三个列表</h4>
<p>Deferred有三个状态：</p>
<ol>
<li>pending</li>
<li>resolved</li>
<li>rejected</li>
</ol>
<p>pending状态是最初状态，它等待resolve操作或reject操作，使用resolve操作表示成功，将跳转到resolved状态，而使用reject将跳转到rejected状态，这两个转变是不可逆的。另外在pending状态下可以无限次调用notify操作</p>
<p>事实上，每个操作对应着一系列的回调函数，看一下定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> tuples = [
    [ <span class="string">"resolve"</span>, <span class="string">"done"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"resolved"</span> ],
    [ <span class="string">"reject"</span>, <span class="string">"fail"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"rejected"</span> ],
    [ <span class="string">"notify"</span>, <span class="string">"progress"</span>, jQuery.Callbacks(<span class="string">"memory"</span>) ]
],
</pre></td></tr></table></figure>


<p>可以看到，这里为resolve、reject、notify这三个操作分别创建了Callbakcs的实例。这里为三个操作的具体定义如下：</p>
<ol>
<li>resolve方法，对应的添加回调函数的方法是done，回调函数列表类型是once和memory，运行后状态转变到resolved</li>
<li>reject方法，对应的添加回调函数的方法是fail，回调函数列表类型是once和memory，运行后状态转变到rejected</li>
<li>notify方法，对应的添加回调函数的方法为progress，回调函数列表类型是memory，说明可执行多次，执行后不会转变状态</li>
</ol>
<p>构造函数下面，会为每一个操作在Promise对象和Deferred对象上生成对应的函数（Promise上是：done、fail、progress。Deferred上是：resolve、reject、notify）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="comment">/*针对三个操作分别进行加工*/</span>
jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
    <span class="comment">/*获取操作的回调函数列表*/</span>
    <span class="keyword">var</span> list = tuple[ <span class="number">2</span> ],
        <span class="comment">/*获取操作执行后的状态*/</span>
        stateString = tuple[ <span class="number">3</span> ];

    <span class="comment">// promise[ done | fail | progress ] = list.add</span>
    <span class="comment">/*为promise对象分别生成done、fail、progress方法，直接映射到对应的回调函数列表对象的add添加方法*/</span>
    promise[ tuple[<span class="number">1</span>] ] = list.add;

    <span class="comment">// Handle state</span>
    <span class="comment">/* 如果状态会改变，说明是resolve方法或reject方法，由于状态转变不可逆，所以需要在回调函数列表最后添加三个函数，分别用于状态修改、使回调函数列表无效、将回调函数列表锁住*/</span>
    <span class="keyword">if</span> ( stateString ) {
        list.add(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="comment">// state = [ resolved | rejected ]</span>
            state = stateString;

        <span class="comment">// [ reject_list | resolve_list ].disable; progress_list.lock</span>
        }, tuples[ i ^ <span class="number">1</span> ][ <span class="number">2</span> ].disable, tuples[ <span class="number">2</span> ][ <span class="number">2</span> ].lock );
    }
    
    <span class="comment">// deferred[ resolve | reject | notify ]</span>
    <span class="comment">/*在deferred上添加resolve、reject、notify方法，分别映射到其回调函数列表的fireWith上*/</span>
    deferred[ tuple[<span class="number">0</span>] ] = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === deferred ? promise : <span class="keyword">this</span>, <span class="built_in">arguments</span> );
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*为deferred对象添加resolveWith，rejectWith，notifyWith，对应的回调函数列表的fireWith*/</span>
    deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ] = list.fireWith;
});
</pre></td></tr></table></figure>


<p>上面的三种操作，只是定义了名称，这里才是真正生成对应函数的地方。jq会为每个Deferred对象生成6个方法：</p>
<ol>
<li>resolve</li>
<li>reject</li>
<li>notify</li>
<li>resolveWith</li>
<li>rejectWith</li>
<li>notifyWith</li>
</ol>
<p>上面三个实际上是直接调用下面三个，只不过加了个默认的参数。下面三个实际上就是对应回调函数列表的fireWith方法。</p>
<p>同时，这里还会为promise增加三个方法：</p>
<ol>
<li>done</li>
<li>fail</li>
<li>progress</li>
</ol>
<p>这三个方法就是为对应的回调函数列表添加新函数的方法，直接映射到对应回调函数列表的add方法就行了</p>
<p>另外需要注意一下resolve和reject方法的一次性，实际上也就是在回调函数列表最后加上disable和lock方法</p>
<h3 id="promise对象">promise对象</h3>
<p>上面反复说了Promise对象，来看看Promise对象的真正面貌：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>promise = {
    <span class="comment">/*获得当前状态的方法*/</span>
    state: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> state;
    },
    <span class="comment">/*无论执行成功与否，都执行参数中的回调*/</span>
    always: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        deferred.done( <span class="built_in">arguments</span> ).fail( <span class="built_in">arguments</span> );
        <span class="keyword">return</span> <span class="keyword">this</span>;
    },
    <span class="comment">/*顺序声明三个函数，分别在成功，失败，执行中时进行调用，返回一个promise对象*/</span>
    then: <span class="function"><span class="keyword">function</span><span class="params">( <span class="comment">/* fnDone, fnFail, fnProgress */</span> )</span> {</span>
        <span class="comment">/*then的代码*/</span>
    },
    <span class="comment">// Get a promise for this deferred</span>
    <span class="comment">// If obj is provided, the promise aspect is added to the object</span>
    <span class="comment">/*获取promise对象*/</span>
    promise: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> {</span>
        <span class="keyword">return</span> obj != <span class="literal">null</span> ? jQuery.extend( obj, promise ) : promise;
    }
},
deferred = {};
<span class="comment">/*pipe方法，实际上就是then，为了符合标准罢了*/</span>
promise.pipe = promise.then;
<span class="comment">/*这里为Promise添加了done、fail、progress方法*/</span>
<span class="comment">/*这里为Deferred添加了resolve、resolveWith、reject、rejectWith、notify、notifyWith方法*/</span>
jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
    <span class="comment">/*上面的代码*/</span>
});
<span class="comment">/*将Promise对象的所有方法拷贝给Deferred对象*/</span>
promise.promise( deferred );
</pre></td></tr></table></figure>


<p>这里可以看到，promise对象提供了几个接口：</p>
<ol>
<li>state：获取当前Deferred对象的状态</li>
<li>always：欧诺更是使用done和fail，使得参数中的方法在deferred成功和失败时都执行</li>
<li>then：使用done、fail、progress分别绑定函数，代码较多，后面再讲</li>
<li>promise：如果对象存在，向一个对象添加promise对象中的接口，否则直接返回promise对象</li>
<li>pipe：就是then，别名而已</li>
<li>done，fail，progress：上面介绍过，不赘述了</li>
</ol>
<h4 id="Promise和Deferred的区别">Promise和Deferred的区别</h4>
<p>这里在申明了promise对象之后，在Deferred对象中添加了promise所有的方法。另外Deferred对象拥有之前说的resolve等6个方法，Deferred对象和Promise对象的区别就很明显了：Promise实际上就是没有resolve、resolveWith、reject、rejectWith、notify、notifyWith这六个方法，其他和Deferred对象一样</p>
<h4 id="then和pipe">then和pipe</h4>
<p>上面略过了then方法，这里单独拉出来说一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>then: <span class="function"><span class="keyword">function</span><span class="params">( <span class="comment">/* fnDone, fnFail, fnProgress */</span> )</span> {</span>
    <span class="keyword">var</span> fns = <span class="built_in">arguments</span>;
    <span class="comment">/*这里新建了一个Deferred对象，并返回其Promise对象，以构成一个Deferred对象链
    由于这里返回的是Promise对象，没有resolve等方法，所以触发必须在整个Deferred对象链的头上触发
    链上的每个Deferred对象的三个回调函数列表的最后，都会有一个函数，用于触发链的下一个Deferred对象的相对应的回调函数列表
    */</span>
    <span class="keyword">return</span> jQuery.Deferred(<span class="function"><span class="keyword">function</span><span class="params">( newDefer )</span> {</span>
        <span class="comment">/*对于上面三种，分别将函数加入到对应的回调函数列表中*/</span>
        jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
            <span class="keyword">var</span> fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
            <span class="comment">/*向当前Deferred最后添加一个函数，用于触发链的下一个Deferred对象的相关回调函数列表*/</span>
            deferred[ tuple[<span class="number">1</span>] ](<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                <span class="keyword">var</span> returned = fn && fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );
                <span class="comment">/*如果返回值是Deferred对象，获取其Promise对象，并为其绑定相关触发操作*/</span>
                <span class="keyword">if</span> ( returned && jQuery.isFunction( returned.promise ) ) {
                    returned.promise()
                        .done( newDefer.resolve )
                        .fail( newDefer.reject )
                        .progress( newDefer.notify );
                <span class="comment">/*如果不是Deferred对象，直接在新建的deferred对象上添加相关触发操作*/</span>
                } <span class="keyword">else</span> {
                    newDefer[ tuple[ <span class="number">0</span> ] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === promise ? newDefer.promise() : <span class="keyword">this</span>, fn ? [ returned ] : <span class="built_in">arguments</span> );
                }
            });
        });
        fns = <span class="literal">null</span>;
    }).promise();
},
</pre></td></tr></table></figure>


<p>这个函数是Deferred的一个非常重要的函数，它实现了一个Deferred链。这个Deferred链的特点是，只有链的头节点是Deferred对象，后面都是Promise对象，这也意味着，只能在头节点触发resolve、reject、notify操作。触发了操作之后，对应的操作会顺着链传递下去，触发了一个节点resolve，执行完毕后，会自动触发下一个节点的resolve，reject和notify同理。</p>
<p>这里传入的三个函数会分别在当前的Deferred相关操作被触发时执行，如果执行返回的是一个Deferred/Promise对象，获取其Promise对象，新建的Deferred对象将会被链在这个返回的Deferred对象之后。如果返回其他的值，新建的Deferred对象的resolveWith、rejectWith、notifyWith方法会被直接触发，达到链式的效果。</p>
<h3 id="小结-1">小结</h3>
<p>这就是jQuery的Deferred/Promise的全貌了。Promise对象实际上是Deferred对象的除去resolve等6个方法的子集。done、fail、progress分别对应一个回调函数列表，这三个方法实际上就是往对应的回调函数列表中插入函数。但then和pipe不相同，它们会新建一个Deferred对象，并构造一个Deferred对象链。这也让jQuery的Deferred/Promise显得不论不类。</p>
<h2 id="when">when</h2>
<p>when方法提供了将多个Deferred对象聚集的能力，在when方法中传入一些Deferred对象，返回一个Deferred对象。在参数中的所有Deferred对象都被resolve之后，会resolve这个返回的Deferred对象，如果参数中的Deferred有一个被reject了，那么这个返回的Deferred也会被reject。另外，在参数中的Deferred对象resolve时，返沪ideDeferred也会被notify。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre>when: <span class="function"><span class="keyword">function</span><span class="params">( subordinate <span class="comment">/* , ..., subordinateN */</span> )</span> {</span>
    <span class="keyword">var</span> i = <span class="number">0</span>,
        <span class="comment">/*切分参数到数组*/</span>
        resolveValues = slice.call( <span class="built_in">arguments</span> ),
        <span class="comment">/*数组长度*/</span>
        length = resolveValues.length,

        <span class="comment">/* 未完成的需要监听的Deferred对象的个数 */</span>
        remaining = length !== <span class="number">1</span> || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : <span class="number">0</span>,
        <span class="comment">/*新建一个Deferred对象用于管理所有的Deferred对象结果，*不妨就叫管理Deferred吧，如果参数只有一个Deferred，就不需要新建了，直接用它就行了/
        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

        /*
        使用一个计数器来计算的，计数器就是remaining，初始为需要执行的Deferred对象的个数，每有一个Deferred被resolve，就减一，减到0时，所有的Deferred都被resolve了，就触发新建的Deferred的resolve。

        如果有Deferred被resolve，但remaining没有到0，就触发管理Deferred的notify
        */</span>
        updateFunc = <span class="function"><span class="keyword">function</span><span class="params">( i, contexts, values )</span> {</span>
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">( value )</span> {</span>
                contexts[ i ] = <span class="keyword">this</span>;
                values[ i ] = <span class="built_in">arguments</span>.length &gt; <span class="number">1</span> ? slice.call( <span class="built_in">arguments</span> ) : value;
                <span class="keyword">if</span> ( values === progressValues ) {
                    deferred.notifyWith( contexts, values );
                } <span class="keyword">else</span> <span class="keyword">if</span> ( !( --remaining ) ) {
                    deferred.resolveWith( contexts, values );
                }
            };
        },

        progressValues, progressContexts, resolveContexts;

    <span class="comment">/*为每个Deferred对象增加我们的更新函数，如果有reject，那么也触发管理Deferred的reject*/</span>
    <span class="keyword">if</span> ( length &gt; <span class="number">1</span> ) {
        progressValues = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        progressContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        resolveContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        <span class="keyword">for</span> ( ; i &lt; length; i++ ) {
            <span class="comment">/*这里只处理Deferred/Promise，其他不考虑*/</span>
            <span class="keyword">if</span> ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                resolveValues[ i ].promise()
                    .done( updateFunc( i, resolveContexts, resolveValues ) )
                    .fail( deferred.reject )
                    .progress( updateFunc( i, progressContexts, progressValues ) );
            } <span class="keyword">else</span> {
                --remaining;
            }
        }
    }

    <span class="comment">/*如果传入的参数都没有Deferred，直接resolve管理Deferred就好*/</span>
    <span class="keyword">if</span> ( !remaining ) {
        deferred.resolveWith( resolveContexts, resolveValues );
    }
    <span class="comment">/*将这个管理Deferred对象返回*/</span>
    <span class="keyword">return</span> deferred.promise();
}
</pre></td></tr></table></figure>


<p>从上面可以看到主要的实现思路就是，新建一个管理Deferred对象，它期望在参数中所有的Deferred被resolve后，执行自己的resolve操作。内部使用了一个计数器remaining，用于表明还有多少个Deferred尚未resolve。当这个计数器变成0时，所有的Deferred都被resolve了，那么这个管理Deferred也可以被resolve了。</p>
<p>为了维护这个计数器，在每个Deferred的done回调函数列表最后，绑定一个updateFunc函数，这个函数内部会修改remaining，以及判断是应该执行管理Deferred对象的resolve还是notify</p>
<p>而由于任何一个Deferred被reject的话，管理Deferred都会被reject，所以直接在每一个Deferred的fail回调函数列表上添加管理Deferred的reject方法就行了</p>
<p>另外需要注意一下参数中只有一个或没有Deferred的情况，前者可以省去创建管理Deferred对象，直接使用参数中的Deferred对象作为管理对象就行了。后者则可以直接执行resolve方法</p>
<h2 id="总结">总结</h2>
<p>jQuery中使用Deferred/Promise对象进行异步管理，其内部维护了三个Callbacks回调函数列表，这与常规的Promise的链式实现并不一致。在稍早的版本中，then方法其实也是和done、fail、progress一样往回调函数列表里添加方法，并不会形成Deferred链，后来Resig估计也发现了自己理解错了标准，于是乎通过pipe和then生成Deferred链，但这种Callbacks和Deferred链同时存在的方式，显得不伦不类，不过普通的需求基本上都能满足。jQuery的ready、ajax等都是使用Deferred/Promise来进行异步控制的</p>

      
    </div>
    <footer class="article-footer">
      
        <a href="http://hiservicerd.github.io/2014/05/17/jquery-source-promise/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery/">jQuery</a></li></ul>

      <div class="jiathis_style">
        <a class="jiathis_button_qzone"></a>
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_tqq"></a>
        <a class="jiathis_button_weixin"></a>
        <a class="jiathis_button_renren"></a>
        <a class="jiathis_button_xiaoyou"></a>
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <a class="jiathis_counter_style"></a>
      </div>
      <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1394026832027748" charset="utf-8"></script>
    </footer>
  </div>
  
</article>


  
    <article id="post-who-are-we" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/13/who-are-we/" class="article-date">
  <time datetime="2014-05-13T15:48:01.000Z" itemprop="datePublished">5月 13 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/13/who-are-we/">我们是海斯维思研发团队</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>北京海斯维思信息科技有限公司是一家提供IT综合服务的高科技企业，业务涵盖：IT产品化服务、应用软件开发、系统集成等。一直以为中国中、小企业提升IT核心竞争力为使命，以坚实的技术实力、对客户业务的良好理解以及高效的实施队伍，为行业客户、企业集团提供面向业务的解决方案、定制化和产品化的专业IT服务。而我们，是海斯维思信息科技有限公司的研发团队</p>

      
    </div>
    <footer class="article-footer">
      
        <a href="http://hiservicerd.github.io/2014/05/13/who-are-we/#disqus_thread" class="article-comment-link">Comments</a>
      
      
      <div class="jiathis_style">
        <a class="jiathis_button_qzone"></a>
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_tqq"></a>
        <a class="jiathis_button_weixin"></a>
        <a class="jiathis_button_renren"></a>
        <a class="jiathis_button_xiaoyou"></a>
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <a class="jiathis_counter_style"></a>
      </div>
      <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1394026832027748" charset="utf-8"></script>
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术/">前端技术</a><span class="category-list-count">7</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/响应式/">响应式</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 20.00px;">CSS</a><a href="/tags/HTML/" style="font-size: 20.00px;">HTML</a><a href="/tags/JavaScript/" style="font-size: 15.00px;">JavaScript</a><a href="/tags/jQuery/" style="font-size: 10.00px;">jQuery</a><a href="/tags/响应式/" style="font-size: 10.00px;">响应式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05">五月 2014</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/">使用导航计时监测渲染关键路径</a>
          </li>
        
          <li>
            <a href="/2014/05/21/google-google-adding-interactivity-with-javaScript/">通过JavaScript增加交互性</a>
          </li>
        
          <li>
            <a href="/2014/05/21/google-render-blocking-css/">CSS的渲染阻塞</a>
          </li>
        
          <li>
            <a href="/2014/05/20/google-render-tree-construction-layout-and-paint/">渲染树的构建，布局和绘制</a>
          </li>
        
          <li>
            <a href="/2014/05/20/google-constructing-the-object-model/">构建对象模型</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 HiServiceRD<br>
      Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">文章</a>
  
    <a href="https://github.com/HiServiceRD" class="mobile-nav-link">GIT</a>
  
</nav>
    
<script>
  var disqus_shortname = 'hiservicerd';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript" src="/js/script.js"></script>
  </div>
</body>
</html>