<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Tag: JavaScript | 海斯维思研发团队</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta content="website" property="og:type">
<meta content="海斯维思研发团队" property="og:title">
<meta content="http://hiservicerd.github.io/tags/JavaScript/" property="og:url">
<meta property="og:image">
<meta content="海斯维思研发团队" property="og:site_name">
<meta property="og:description">
<meta content="summary" name="twitter:card">
  
    <link rel="alternative" href="/atom.xml" title="海斯维思研发团队" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-51090540-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">海斯维思研发团队</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">文章</a>
        
          <a class="main-nav-link" href="https://github.com/HiServiceRD">GIT</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://hiservicerd.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-google-measuring-the-critical-rendering-path-with-navigation-timing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/" class="article-date">
  <time datetime="2014-05-21T08:20:03.000Z" itemprop="datePublished">5月 21 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/">使用导航计时监测渲染关键路径</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）</p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>导航计时为监测渲染关键路径提供了高分辨率的时间戳</li>
<li>浏览器在到达渲染关键路径的不同阶段时，会触发一系列的事件</li>
</ul>
<h3 id="用于监测的时间戳">用于监测的时间戳</h3>
<p>好的性能策略都是建立在良好的测量基础之上的。下面这张图说明了导航计时接口提供的API：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/1.png" alt="导航计时接口提供的API"></p>
<p>上面的每一个标签都提供了一个方法，用于检测每一个页面加载的高分辨率的时间戳。在这里，我们仅仅介绍除了与网络相关的时间戳的哪些一部分时间戳，剩下的我们会在以后的章节作介绍</p>
<p>那么，这些时间戳代表着什么？</p>
<ul>
<li>domLoading：整个处理过程开始的时间，也就是浏览器开始解析HTML文档的第一个字节的时间</li>
<li>domInteractive：浏览器解析完所有HTML，并完成DOM构建的时间</li>
<li>domContentLoaded：开始构建渲染树的时间点，就是DOM构建完毕后，若没有样式以及阻塞的JavaScript运行的时间点<ul>
<li>许多JavaScript框架都会监听这个事件，然后执行他们自己的逻辑。因此浏览器提供了EventStart和EventEnd两个时间戳来允许我们知道具体运行消耗的时间</li>
</ul>
</li>
<li>domComplete：和名字一样，记录了页面上的所有资源都下载完成（包括图片）以及所有处理逻辑都结束后的时间点。这个时间点过后，浏览器旋转的加载标记将不再旋转了</li>
<li>loadEvent：最后，浏览器触发onload事件来执行一些其他的应用逻辑</li>
</ul>
<h3 id="里程碑">里程碑</h3>
<p>根据HTML的规范，浏览器会检测所有事件：什么时候应该触发事件，应该满足哪些条件等等。对于我们来说，我们只需要关注渲染关键路径上的一些“里程碑”事件：</p>
<ul>
<li>domIneractive：说明DOM构建完毕</li>
<li>domContentLoaded：当DOM和CSSOM都完成后触发<ul>
<li>如果没有“解析器阻塞”的JavaScript代码，documentContentLoaded将直接在domInteractive之后触发</li>
</ul>
</li>
<li>domComplete：当页面及其所有资源全部完毕时触发</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Measure<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
      <span class="function"><span class="keyword">function</span> <span class="title">measureCRP</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> t = window.performance.timing,
          interactive = t.domInteractive - t.domLoading,
          dcl = t.domContentLoadedEventStart - t.domLoading,
          complete = t.domComplete - t.domLoading;
        <span class="keyword">var</span> stats = document.createElement(<span class="string">'p'</span>);
        stats.textContent = <span class="string">'interactive: '</span> + interactive + <span class="string">'ms, '</span> +
            <span class="string">'dcl: '</span> + dcl + <span class="string">'ms, complete: '</span> + complete + <span class="string">'ms'</span>;
        document.body.appendChild(stats);
      }
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">onload</span>=<span class="value">"measureCRP()"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>上面的例子乍看之下可能比较吓人，但实际上非常简单，导航计时API捕获了相关的时间戳，而我们的JavaScript代码放在onload事件的回调函数中，只有触发了onload事件，才会执行。onload事件只有在domInteractive、domContentLoaded和domComplete事件都完成之后才会触发，所以我们可以捕获到这些时间戳之间的差值，算出每个阶段所耗费的时间</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/2.png" alt="时间戳检测结果"></p>
<p>综上所述，我们可以获得一些“里程碑事件”以及一些简单的函数来输出测量结果。当然我们可以不将这些数据输出到页面上，而是发送这些分析的数据到专门的分析服务器（Google的分析工具就会自动做这些事），这样就能很方便的检测网页的性能，确定候选页面，并尝到优化所带来的甜头。</p>

      
    </div>
    <footer class="article-footer">
      
        <a href="http://hiservicerd.github.io/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

      <div class="jiathis_style">
        <a class="jiathis_button_qzone"></a>
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_tqq"></a>
        <a class="jiathis_button_weixin"></a>
        <a class="jiathis_button_renren"></a>
        <a class="jiathis_button_xiaoyou"></a>
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <a class="jiathis_counter_style"></a>
      </div>
      <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1394026832027748" charset="utf-8"></script>
    </footer>
  </div>
  
</article>


  
    <article id="post-google-google-adding-interactivity-with-javaScript" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/21/google-google-adding-interactivity-with-javaScript/" class="article-date">
  <time datetime="2014-05-21T08:20:02.000Z" itemprop="datePublished">5月 21 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/21/google-google-adding-interactivity-with-javaScript/">通过JavaScript增加交互性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。</p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>JavaScript可以对DOM和CSSOM进行查询和修改</li>
<li>JavaScript的执行会阻塞CSSOM的构建</li>
<li>JavaScript阻塞DOM树的构建，除非显式的声明为异步</li>
</ul>
<h3 id="JavaScript造成的阻塞">JavaScript造成的阻塞</h3>
<p>JavaScript一个跑在浏览器中的动态语言，JavaScript允许我们修改页面中的每一方面：我们能够通过在DOM树上添加或删除节点来修改网页内容，也能修改元素的CSSOM属性，还能处理用户输入等等。这里提供了一个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
      <span class="keyword">var</span> span = document.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];
      span.textContent = <span class="string">'interactive'</span>; <span class="comment">// change DOM text content</span>
      span.style.display = <span class="string">'inline'</span>;  <span class="comment">// change CSSOM property</span>
      <span class="comment">// create a new element, style it, and append it to the DOM</span>
      <span class="keyword">var</span> loadTime = document.createElement(<span class="string">'div'</span>);
      loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();
      loadTime.style.color = <span class="string">'blue'</span>;
      document.body.appendChild(loadTime);
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<ul>
<li>JavaScript允许我们进入到DOM树中，甚至获取隐藏的span元素。事实上隐藏的元素并不存在于渲染树中，但它仍然存在于DOM树中。因此，当我们获取到它的引用时，我们能够修改其内部的文字（通过textContent进行修改），我们甚至能修改它的display样式值，从‘none’改到‘inline’。这上面说的都完成之后，我们的网页将会显示“Hello interative students!”</li>
<li>JavaScript也允许我们创建节点，为节点赋予样式，在DOM中添加和删除节点。事实上，在技术上，我们的整个页面可以通过一个巨大JavaScript文件来一个一个创建节点并给他们赋予样式。这同样能工作，但使用HTML和CSS明显更加简单。JavaScript函数的第二部分创建了一个div元素，并设定了文字，赋予了样式，然后将其添加到body上。</li>
</ul>
<p>这里，我们修改了已经存在DOM节点的的内容和CSS样式，并在文档中加入了一个全新的节点。JavaScript为我们的网页提供了更强的能力和灵活性。</p>
<p>然而，这里潜伏着一个大的性能问题。JavaScript为我们提供了更强的能力，但也为渲染的方式和时间带来的一定的限制。</p>
<p>首先，注意上面的例子中，我们的内联脚本放在了页面的底部。这是为什么呢？你可以自己试试，如果你将脚本移动到span元素的上面，可以看到script里面的脚本将会运行失败并报出错误说在文档中找不到任何span元素（<code>getElementsByTagName(&#39;span&#39;)</code>返回null）。这说明了很重要的一点：脚本运行的位置，是其在文档中的位置。当HTML解析器发现到了script标签时，他会暂停DOM的构建并将控制权交给JavaScript引擎。一旦JavaScript运行完毕，浏览器将会回到之前的位置，继续DOM的构建。</p>
<p>换句话说，脚本内部无法发现其后面的元素，因为他们还没有被处理过。或者再换个说法：<strong>运行内联脚本将阻塞DOM的构建，这也意味着阻塞页面初始的渲染</strong>。</p>
<p>页面中的脚本的另一个点在于：脚本不仅仅能够修改DOM，也能够修改CSSOM。事实上，上面的例子中，我们已经修改了span元素的display属性，将它从none修改到inline</p>
<p>那么，如果浏览器还没有完成CSSOM的下载和构建，就需要运行脚本，浏览器会怎么做？答案很简单，但效率不好：<strong>浏览器将延迟脚本的执行，直到CSSOM的下载和构建全部完成之后，才会执行。与此同时，在我们等待的时候，DOM构建也会阻塞。</strong></p>
<p>简而言之，JavaScript引入了很多的DOM、CSSOM之间的相互依赖，同时JavaScript的执行将会在浏览器处理和页面渲染时导致明显的时延：</p>
<ol>
<li>脚本在文档中的位置很重要</li>
<li>发现script标签时，会暂停DOM的构建，直到脚本被运行完成，DOM构建才会继续</li>
<li>JavaScript能够查询和修改DOM和CSSOM</li>
<li>JavaScript只有在CSSOM被构建完毕之后才会执行</li>
</ol>
<p>当我们谈及“渲染性能优化”，在很大程度上，我们谈及的是HTML、CSS和JavaScript之间的依赖关系图。</p>
<h3 id="解析器的阻塞和异步JavaScript">解析器的阻塞和异步JavaScript</h3>
<p>默认情况下，JavaScript的执行是“解析器阻塞”的：当浏览器在文档中遇到一个script标签时，DOM的构建会被暂停，控制权递交给JavaScript运行，DOM的构建将会在JavaScript运行完成之后继续执行。这可以从上面的内联脚本例子中看出来。事实上，内联脚本总是“解析器阻塞”的，除非特别照顾这些代码来推迟其执行。</p>
<p>那么如何通过script标签包含脚本？我们继续使用之前的的例子，将代码放在单独文件中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script External<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"app.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>




<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> span = document.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];
span.textContent = <span class="string">'interactive'</span>; <span class="comment">// 改变DOM中的文本</span>
span.style.display = <span class="string">'inline'</span>;  <span class="comment">// 改变CSSOM属性</span>
<span class="comment">// 创建一个新元素，为其添加样式，并将其加入到DOM中</span>
<span class="keyword">var</span> loadTime = document.createElement(<span class="string">'div'</span>);
loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();
loadTime.style.color = <span class="string">'blue'</span>;
document.body.appendChild(loadTime);
</pre></td></tr></table></figure>


<p>你是否认为通过<code>&lt;scirpt&gt;</code>引入的JavaScript代码和内联JavaScrip它的执行顺序不同？当然，这个答案是否定的，这两者的处理方式几样。无论是前者还是后者，浏览器都在处理后面的文档之前，暂停并执行脚本。<strong>然而：在当浏览器使用外部JavaScript文件时，也不得不暂停并等待脚本从磁盘、缓存、或陈远程服务器中获取。这可能在为页面渲染带来上千万毫秒的时延</strong></p>
<p>有一个好戏，我们确实有一个解决方法。默认情况下，所有的JavaScript都是“解析器阻塞”的，浏览器也不知道JavaScript脚本究竟会在网页山做些什么，因此它会假定最坏的情况并阻塞解析器。然而，如果我们有办法告诉浏览器我们的脚本不需要在它所处的文档位置上被执行，那会怎样呢？如果这样做，浏览器会继续DOM构建，并直到DOM构建完成后，运行脚本，无论是文件是从高速缓存直接中获取还是从远程服务器中获取。</p>
<p>那么我们怎样实现呢，我们能直接标记脚本为异步脚本：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre> <span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script Async<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"app.js"</span> <span class="attribute">async</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>增加了async属性能够高速浏览器，它不会在下载和执行过程中阻塞DOM构建。这是一个巨大的效率提升！</p>

      
    </div>
    <footer class="article-footer">
      
        <a href="http://hiservicerd.github.io/2014/05/21/google-google-adding-interactivity-with-javaScript/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

      <div class="jiathis_style">
        <a class="jiathis_button_qzone"></a>
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_tqq"></a>
        <a class="jiathis_button_weixin"></a>
        <a class="jiathis_button_renren"></a>
        <a class="jiathis_button_xiaoyou"></a>
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <a class="jiathis_counter_style"></a>
      </div>
      <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1394026832027748" charset="utf-8"></script>
    </footer>
  </div>
  
</article>


  
    <article id="post-jquery-source-promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/17/jquery-source-promise/" class="article-date">
  <time datetime="2014-05-17T07:23:00.000Z" itemprop="datePublished">5月 17 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端技术/">前端技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/17/jquery-source-promise/">jQuery中的异步控制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/img/jquery-source-promise/jQuery.jpg" alt="Write less, do more."></p>
<h2 id="简介">简介</h2>
<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>
<h2 id="jQuery-Callbacks">jQuery.Callbacks</h2>
<p>这是回调函数列表的构造器，内部使用一个数组来保存回调函数列表，并提供一系列的方法来维护这个列表。另外这个列表还有一些状态</p>
<h3 id="配置选项">配置选项</h3>
<p>创建一个回调函数列表可能会用到如下参数：</p>
<ol>
<li>options：一个选项类表，确定了回调函数列表如何工作，以及一些常见配置</li>
<li>once：默认情况下回调函数列表的执行时没有次数限制的，但如果设置了once，将设置回调函数列表只会被执行一次</li>
<li>memory：决定了在回调函数列表在执行过程中，是否会保留上一个函数执行的结果</li>
<li>unique：决定了回调函数列表中的函数能否重复</li>
<li>stopOnFalse：决定了在一个回调函数返回false后，后面的回调函数将不会被执行</li>
</ol>
<p>接下来看看构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>options = <span class="keyword">typeof</span> options === <span class="string">"string"</span> ?
    ( optionsCache[ options ] || createOptions( options ) ) :
    jQuery.extend( {}, options );
</pre></td></tr></table></figure>


<p>options可以是字符串，如<code>&quot;once memory&quot;</code>，如果是字符串，就先进行解析并缓存。如果options是对象，那么直接options就是这个对象</p>
<h3 id="私有变量">私有变量</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">var</span> <span class="comment">// Last fire value (for non-forgettable lists)</span>
    <span class="comment">/*用于存放运行结果*/</span>
    memory,
    <span class="comment">/*标志所有回调函数列表是否被触发过*/</span>
    fired,
    <span class="comment">/*标志当前正在执行回调函数列表中的函数*/</span>
    firing,
    <span class="comment">/*第一个被执行的回调函数*/</span>
    firingStart,
    <span class="comment">/*回调函数列表的长度*/</span>
    firingLength,
    <span class="comment">/*当前执行的回调函数在回调函数列表中的下标，如果移除了回调函数，将会对其进行修改*/</span>
    firingIndex,
    <span class="comment">/*保存回调函数的列表*/</span>
    list = [],
    <span class="comment">/*如果回调函数列表时多次执行的，那么在运行回调函数列表的过程中，可能会再次触发，这时候就需要一个队列进行等待了*/</span>
    stack = !options.once && [],
</pre></td></tr></table></figure>


<p>这里面都是一些私有变量，没啥太多好说的，官方代码里也对每个变量都写了注释</p>
<h3 id="触发函数fire">触发函数fire</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre>fire = <span class="function"><span class="keyword">function</span><span class="params">( data )</span> {</span>
    <span class="comment">/*如果使用了memory配置，data会先被保存在memory中*/</span>
    memory = options.memory && data;
    <span class="comment">/*表明这个回调函数列表已经被触发过了*/</span>
    fired = <span class="literal">true</span>;
    <span class="comment">/*确定当前执行的回调函数在回调函数列表中的位置*/</span>
    firingIndex = firingStart || <span class="number">0</span>;
    <span class="comment">/*将起始设为0*/</span>
    firingStart = <span class="number">0</span>;
    <span class="comment">/*获取回调函数列表的总长度*/</span>
    firingLength = list.length;
    <span class="comment">/*修改状态为正在执行*/</span>
    firing = <span class="literal">true</span>;
    <span class="comment">/*依次执行回调函数*/</span>
    <span class="keyword">for</span> ( ; list && firingIndex &lt; firingLength; firingIndex++ ) {
        <span class="comment">/*如果回调函数返回值是false且设定了stopOnFalse，那么执行结束，memory清空*/</span>
        <span class="keyword">if</span> ( list[ firingIndex ].apply( data[ <span class="number">0</span> ], data[ <span class="number">1</span> ] ) === <span class="literal">false</span> && options.stopOnFalse ) {
            memory = <span class="literal">false</span>; <span class="comment">// To prevent further calls using add</span>
            <span class="keyword">break</span>;
        }
    }
    <span class="comment">/*修改正在执行状态为false*/</span>
    firing = <span class="literal">false</span>;
    
    <span class="comment">/*如果等待队列中有数据，那么需要获取等待队列中的数据，再次执行回调函数列表*/</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">/*多次执行的话，stack是个数组*/</span>
        <span class="keyword">if</span> ( stack ) {
            <span class="comment">/*从等待队列中弹出数据再次执行*/</span>
            <span class="keyword">if</span> ( stack.length ) {
                fire( stack.shift() );
            }
        <span class="comment">/*如果是单次执行，且所有函数正常执行完成，缓存了最终结果，清空回调函数列表*/</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) {
            list = [];
        <span class="comment">/*否则说明函数没有正常执行完成，将回调函数列表设为无效*/</span>
        } <span class="keyword">else</span> {
            self.disable();
        }
    }
},
</pre></td></tr></table></figure>


<p>这里可以看到触发回调函数列表的逻辑。触发后，会依次执行列表中的回调函数，这里执行时有一个stopOnFalse设置，如果函数返回false，那么就终止执行。另外在执行过程中，如果又有新的执行请求到来，需要将执行请求放入等待队列之中，等待当前执行中的所有回调函数完成之后再重新执行。当然这个设定对once类型的回调函数列表不起作用</p>
<h3 id="实例">实例</h3>
<p>接下来创建了一个self对象，并进行了返回，这是个一个构造函数，说明self是真正返回的实例。看看实例中有哪些方法：</p>
<h4 id="add">add</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre>add: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">//首先保存当前列表长度</span>
        <span class="keyword">var</span> start = list.length;
        <span class="comment">/*使用jQuery.each方法遍历深度遍历arguments：
        1. 如果键值对中值为函数，那么直接添加，需要注意的是如果有unique选项，在添加前需要判重
        2. 如果值为对象那么遍历这个对象进行添加 */</span>
        (<span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">( args )</span> {</span>
            jQuery.each( args, <span class="function"><span class="keyword">function</span><span class="params">( _, arg )</span> {</span>
                <span class="keyword">var</span> type = jQuery.type( arg );
                <span class="keyword">if</span> ( type === <span class="string">"function"</span> ) {
                    <span class="keyword">if</span> ( !options.unique || !self.has( arg ) ) {
                    list.push( arg );
                    }
                } <span class="keyword">else</span> <span class="keyword">if</span> ( arg && arg.length && type !== <span class="string">"string"</span> ) {
                    <span class="comment">// Inspect recursively</span>
                    add( arg );
                }
            });
        })( <span class="built_in">arguments</span> );
        <span class="comment">/*如果正在执行回调函数列表，那么需要维护一下长度*/</span>
        <span class="keyword">if</span> ( firing ) {
            firingLength = list.length;
        <span class="comment">/*如果memory中已经有值，执行所有新增加的回调函数*/</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) {
            firingStart = start;
            fire( memory );
        }
    }
    <span class="comment">/*返回this方便链式操作*/</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>这个方法往回调函数列表中添加新函数，jQuery会非常智能的使用each对参数进行深度遍历来添加所有函数。需要注意的是，如果回调函数列表正在执行，添加之后需要维护长度。另外如果memory中有数据，我们就应该立即执行新添加的回调函数</p>
<h4 id="remove">remove</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>remove: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">/*遍历arguments，对每个函数分执行删除操作*/</span>
        jQuery.each( <span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span><span class="params">( _, arg )</span> {</span>
            <span class="keyword">var</span> index;
            <span class="comment">/*通过jQuery.inArray获取函数在回调函数列表中的位置*/</span>
            <span class="keyword">while</span> ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -<span class="number">1</span> ) {
                <span class="comment">/*删除掉这个函数*/</span>
                list.splice( index, <span class="number">1</span> );
                <span class="comment">/*如果正在执行回调函数，需要维护长度和当前正在执行的回调函数的下标*/</span>
                <span class="keyword">if</span> ( firing ) {
                    <span class="keyword">if</span> ( index &lt;= firingLength ) {
                        firingLength--;
                    }
                    <span class="keyword">if</span> ( index &lt;= firingIndex ) {
                        firingIndex--;
                    }
                }
            }
        });
    }
    <span class="comment">/*返回this方便链式操作*/</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>这里同样使用<code>jQuery.each</code>遍历所有参数，获取其中的函数，通过inArray判定，然后通过splice移除。这里需要注意的是，在回调函数列表正在执行时，删除操作同样需要维护长度，另外还可能需要维护当前正在运行的函数的下标</p>
<h4 id="has_(fn)">has (fn)</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>has: <span class="function"><span class="keyword">function</span><span class="params">( fn )</span> {</span>
    <span class="keyword">return</span> fn ? jQuery.inArray( fn, list ) &gt; -<span class="number">1</span> : !!( list && list.length );
},
</pre></td></tr></table></figure>


<p>判断一个函数是否在回调函数列表中，分判断函数和判断列表两种情况：</p>
<ol>
<li>若有fn，直接用inArray判定</li>
<li>若无fn，直接判断列表是否有长度不为0的list列表</li>
</ol>
<h4 id="empty">empty</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>empty: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    list = [];
    firingLength = <span class="number">0</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>清空回调函数列表，没啥好说的…list社为空数组，长度设为0</p>
<h4 id="disable和disabled">disable和disabled</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>disabled: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    list = stack = memory = <span class="literal">undefined</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
disabled: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !list;
},
</pre></td></tr></table></figure>


<p>将回调函数列表设定为无效，实际上就是将list，stack，memory设成undefined，检测无效也很简单，直接通过list判断，没设定无效情况下，list都是数组，其必然是真值</p>
<h4 id="lock和locked">lock和locked</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>lock: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    stack = <span class="literal">undefined</span>;
    <span class="keyword">if</span> ( !memory ) {
        self.disable();
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
locked: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !stack;
},
</pre></td></tr></table></figure>


<p>lock和locked故名思意就是将回调函数列表锁住，其判定方式是stack是否存在，在once设置下，stack本来就不存在，直接就是locked。而非once情况下，lock函数会设定stack为undefined，这样就无法在回调函数运行时进行fire了，就算锁住了。另外，如果没有memory，说明回调函数执行失败了，直接disbale掉就好</p>
<h4 id="fireWith和fire">fireWith和fire</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>fireWith: <span class="function"><span class="keyword">function</span><span class="params">( context, args )</span> {</span>
    <span class="comment">/*如果回调函数列表还有效，没触发过或者可以多次触发，那么就满足触发条件了*/</span>
    <span class="keyword">if</span> ( list && ( !fired || stack ) ) {
        args = args || [];
        args = [ context, args.slice ? args.slice() : args ];
        <span class="comment">/*如果正在出发，就放到等待队列中*/</span>
        <span class="comment">/*如果once且触发过或正在触发，可以从私有方法fire中看到，fired是在方法一开始被设置的，所以无法通过上面的fired条件，能到这里必然是没有触发或多次触发的情况。而没有触发不存在firing状态，也就不需要检测stack了*/</span>
        <span class="keyword">if</span> ( firing ) {
            stack.push( args );
        <span class="comment">/*否则直接触发*/</span>
        } <span class="keyword">else</span> {
            fire( args );
        }
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
fire: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    self.fireWith( <span class="keyword">this</span>, <span class="built_in">arguments</span> );
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
fired: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !!fired;
}
</pre></td></tr></table></figure>


<p>这里fire实际上使用fireWith实现的，我们只需要看fireWith就好。这里fireWith将触发回调函数列表的执行，触发条件是：当前回调函数列表有效，且没触发过或可以多次触发（stack存在就是可以多次触发），需要注意的是，如果正在触发，也就是firing状态时，触发请求将会被放入stack中等待</p>
<p>fired没啥好说的，判断回调函数列表是否被触发过</p>
<h3 id="小结">小结</h3>
<p>这个<code>jQuery.Callbacks</code>本质上就是维护一个数组，这个数组中都是函数。一个特点就是可以通过fire方式去挨个执行这些函数，并提供了一些配置来确定执行的过程以及执行的次数。每个Deferred对象将拥有三个Callbacks实例</p>
<h2 id="Deferred">Deferred</h2>
<p>jQuery的异步控制使用Deferred/Promise，每一个Deferred对象对应一个Promise对象，首先来看看其构造函数</p>
<h3 id="构造函数">构造函数</h3>
<h4 id="三个状态，三个操作，三个列表">三个状态，三个操作，三个列表</h4>
<p>Deferred有三个状态：</p>
<ol>
<li>pending</li>
<li>resolved</li>
<li>rejected</li>
</ol>
<p>pending状态是最初状态，它等待resolve操作或reject操作，使用resolve操作表示成功，将跳转到resolved状态，而使用reject将跳转到rejected状态，这两个转变是不可逆的。另外在pending状态下可以无限次调用notify操作</p>
<p>事实上，每个操作对应着一系列的回调函数，看一下定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> tuples = [
    [ <span class="string">"resolve"</span>, <span class="string">"done"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"resolved"</span> ],
    [ <span class="string">"reject"</span>, <span class="string">"fail"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"rejected"</span> ],
    [ <span class="string">"notify"</span>, <span class="string">"progress"</span>, jQuery.Callbacks(<span class="string">"memory"</span>) ]
],
</pre></td></tr></table></figure>


<p>可以看到，这里为resolve、reject、notify这三个操作分别创建了Callbakcs的实例。这里为三个操作的具体定义如下：</p>
<ol>
<li>resolve方法，对应的添加回调函数的方法是done，回调函数列表类型是once和memory，运行后状态转变到resolved</li>
<li>reject方法，对应的添加回调函数的方法是fail，回调函数列表类型是once和memory，运行后状态转变到rejected</li>
<li>notify方法，对应的添加回调函数的方法为progress，回调函数列表类型是memory，说明可执行多次，执行后不会转变状态</li>
</ol>
<p>构造函数下面，会为每一个操作在Promise对象和Deferred对象上生成对应的函数（Promise上是：done、fail、progress。Deferred上是：resolve、reject、notify）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="comment">/*针对三个操作分别进行加工*/</span>
jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
    <span class="comment">/*获取操作的回调函数列表*/</span>
    <span class="keyword">var</span> list = tuple[ <span class="number">2</span> ],
        <span class="comment">/*获取操作执行后的状态*/</span>
        stateString = tuple[ <span class="number">3</span> ];

    <span class="comment">// promise[ done | fail | progress ] = list.add</span>
    <span class="comment">/*为promise对象分别生成done、fail、progress方法，直接映射到对应的回调函数列表对象的add添加方法*/</span>
    promise[ tuple[<span class="number">1</span>] ] = list.add;

    <span class="comment">// Handle state</span>
    <span class="comment">/* 如果状态会改变，说明是resolve方法或reject方法，由于状态转变不可逆，所以需要在回调函数列表最后添加三个函数，分别用于状态修改、使回调函数列表无效、将回调函数列表锁住*/</span>
    <span class="keyword">if</span> ( stateString ) {
        list.add(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="comment">// state = [ resolved | rejected ]</span>
            state = stateString;

        <span class="comment">// [ reject_list | resolve_list ].disable; progress_list.lock</span>
        }, tuples[ i ^ <span class="number">1</span> ][ <span class="number">2</span> ].disable, tuples[ <span class="number">2</span> ][ <span class="number">2</span> ].lock );
    }
    
    <span class="comment">// deferred[ resolve | reject | notify ]</span>
    <span class="comment">/*在deferred上添加resolve、reject、notify方法，分别映射到其回调函数列表的fireWith上*/</span>
    deferred[ tuple[<span class="number">0</span>] ] = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === deferred ? promise : <span class="keyword">this</span>, <span class="built_in">arguments</span> );
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*为deferred对象添加resolveWith，rejectWith，notifyWith，对应的回调函数列表的fireWith*/</span>
    deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ] = list.fireWith;
});
</pre></td></tr></table></figure>


<p>上面的三种操作，只是定义了名称，这里才是真正生成对应函数的地方。jq会为每个Deferred对象生成6个方法：</p>
<ol>
<li>resolve</li>
<li>reject</li>
<li>notify</li>
<li>resolveWith</li>
<li>rejectWith</li>
<li>notifyWith</li>
</ol>
<p>上面三个实际上是直接调用下面三个，只不过加了个默认的参数。下面三个实际上就是对应回调函数列表的fireWith方法。</p>
<p>同时，这里还会为promise增加三个方法：</p>
<ol>
<li>done</li>
<li>fail</li>
<li>progress</li>
</ol>
<p>这三个方法就是为对应的回调函数列表添加新函数的方法，直接映射到对应回调函数列表的add方法就行了</p>
<p>另外需要注意一下resolve和reject方法的一次性，实际上也就是在回调函数列表最后加上disable和lock方法</p>
<h3 id="promise对象">promise对象</h3>
<p>上面反复说了Promise对象，来看看Promise对象的真正面貌：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>promise = {
    <span class="comment">/*获得当前状态的方法*/</span>
    state: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> state;
    },
    <span class="comment">/*无论执行成功与否，都执行参数中的回调*/</span>
    always: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        deferred.done( <span class="built_in">arguments</span> ).fail( <span class="built_in">arguments</span> );
        <span class="keyword">return</span> <span class="keyword">this</span>;
    },
    <span class="comment">/*顺序声明三个函数，分别在成功，失败，执行中时进行调用，返回一个promise对象*/</span>
    then: <span class="function"><span class="keyword">function</span><span class="params">( <span class="comment">/* fnDone, fnFail, fnProgress */</span> )</span> {</span>
        <span class="comment">/*then的代码*/</span>
    },
    <span class="comment">// Get a promise for this deferred</span>
    <span class="comment">// If obj is provided, the promise aspect is added to the object</span>
    <span class="comment">/*获取promise对象*/</span>
    promise: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> {</span>
        <span class="keyword">return</span> obj != <span class="literal">null</span> ? jQuery.extend( obj, promise ) : promise;
    }
},
deferred = {};
<span class="comment">/*pipe方法，实际上就是then，为了符合标准罢了*/</span>
promise.pipe = promise.then;
<span class="comment">/*这里为Promise添加了done、fail、progress方法*/</span>
<span class="comment">/*这里为Deferred添加了resolve、resolveWith、reject、rejectWith、notify、notifyWith方法*/</span>
jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
    <span class="comment">/*上面的代码*/</span>
});
<span class="comment">/*将Promise对象的所有方法拷贝给Deferred对象*/</span>
promise.promise( deferred );
</pre></td></tr></table></figure>


<p>这里可以看到，promise对象提供了几个接口：</p>
<ol>
<li>state：获取当前Deferred对象的状态</li>
<li>always：欧诺更是使用done和fail，使得参数中的方法在deferred成功和失败时都执行</li>
<li>then：使用done、fail、progress分别绑定函数，代码较多，后面再讲</li>
<li>promise：如果对象存在，向一个对象添加promise对象中的接口，否则直接返回promise对象</li>
<li>pipe：就是then，别名而已</li>
<li>done，fail，progress：上面介绍过，不赘述了</li>
</ol>
<h4 id="Promise和Deferred的区别">Promise和Deferred的区别</h4>
<p>这里在申明了promise对象之后，在Deferred对象中添加了promise所有的方法。另外Deferred对象拥有之前说的resolve等6个方法，Deferred对象和Promise对象的区别就很明显了：Promise实际上就是没有resolve、resolveWith、reject、rejectWith、notify、notifyWith这六个方法，其他和Deferred对象一样</p>
<h4 id="then和pipe">then和pipe</h4>
<p>上面略过了then方法，这里单独拉出来说一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>then: <span class="function"><span class="keyword">function</span><span class="params">( <span class="comment">/* fnDone, fnFail, fnProgress */</span> )</span> {</span>
    <span class="keyword">var</span> fns = <span class="built_in">arguments</span>;
    <span class="comment">/*这里新建了一个Deferred对象，并返回其Promise对象，以构成一个Deferred对象链
    由于这里返回的是Promise对象，没有resolve等方法，所以触发必须在整个Deferred对象链的头上触发
    链上的每个Deferred对象的三个回调函数列表的最后，都会有一个函数，用于触发链的下一个Deferred对象的相对应的回调函数列表
    */</span>
    <span class="keyword">return</span> jQuery.Deferred(<span class="function"><span class="keyword">function</span><span class="params">( newDefer )</span> {</span>
        <span class="comment">/*对于上面三种，分别将函数加入到对应的回调函数列表中*/</span>
        jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
            <span class="keyword">var</span> fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
            <span class="comment">/*向当前Deferred最后添加一个函数，用于触发链的下一个Deferred对象的相关回调函数列表*/</span>
            deferred[ tuple[<span class="number">1</span>] ](<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                <span class="keyword">var</span> returned = fn && fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );
                <span class="comment">/*如果返回值是Deferred对象，获取其Promise对象，并为其绑定相关触发操作*/</span>
                <span class="keyword">if</span> ( returned && jQuery.isFunction( returned.promise ) ) {
                    returned.promise()
                        .done( newDefer.resolve )
                        .fail( newDefer.reject )
                        .progress( newDefer.notify );
                <span class="comment">/*如果不是Deferred对象，直接在新建的deferred对象上添加相关触发操作*/</span>
                } <span class="keyword">else</span> {
                    newDefer[ tuple[ <span class="number">0</span> ] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === promise ? newDefer.promise() : <span class="keyword">this</span>, fn ? [ returned ] : <span class="built_in">arguments</span> );
                }
            });
        });
        fns = <span class="literal">null</span>;
    }).promise();
},
</pre></td></tr></table></figure>


<p>这个函数是Deferred的一个非常重要的函数，它实现了一个Deferred链。这个Deferred链的特点是，只有链的头节点是Deferred对象，后面都是Promise对象，这也意味着，只能在头节点触发resolve、reject、notify操作。触发了操作之后，对应的操作会顺着链传递下去，触发了一个节点resolve，执行完毕后，会自动触发下一个节点的resolve，reject和notify同理。</p>
<p>这里传入的三个函数会分别在当前的Deferred相关操作被触发时执行，如果执行返回的是一个Deferred/Promise对象，获取其Promise对象，新建的Deferred对象将会被链在这个返回的Deferred对象之后。如果返回其他的值，新建的Deferred对象的resolveWith、rejectWith、notifyWith方法会被直接触发，达到链式的效果。</p>
<h3 id="小结-1">小结</h3>
<p>这就是jQuery的Deferred/Promise的全貌了。Promise对象实际上是Deferred对象的除去resolve等6个方法的子集。done、fail、progress分别对应一个回调函数列表，这三个方法实际上就是往对应的回调函数列表中插入函数。但then和pipe不相同，它们会新建一个Deferred对象，并构造一个Deferred对象链。这也让jQuery的Deferred/Promise显得不论不类。</p>
<h2 id="when">when</h2>
<p>when方法提供了将多个Deferred对象聚集的能力，在when方法中传入一些Deferred对象，返回一个Deferred对象。在参数中的所有Deferred对象都被resolve之后，会resolve这个返回的Deferred对象，如果参数中的Deferred有一个被reject了，那么这个返回的Deferred也会被reject。另外，在参数中的Deferred对象resolve时，返沪ideDeferred也会被notify。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre>when: <span class="function"><span class="keyword">function</span><span class="params">( subordinate <span class="comment">/* , ..., subordinateN */</span> )</span> {</span>
    <span class="keyword">var</span> i = <span class="number">0</span>,
        <span class="comment">/*切分参数到数组*/</span>
        resolveValues = slice.call( <span class="built_in">arguments</span> ),
        <span class="comment">/*数组长度*/</span>
        length = resolveValues.length,

        <span class="comment">/* 未完成的需要监听的Deferred对象的个数 */</span>
        remaining = length !== <span class="number">1</span> || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : <span class="number">0</span>,
        <span class="comment">/*新建一个Deferred对象用于管理所有的Deferred对象结果，*不妨就叫管理Deferred吧，如果参数只有一个Deferred，就不需要新建了，直接用它就行了/
        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

        /*
        使用一个计数器来计算的，计数器就是remaining，初始为需要执行的Deferred对象的个数，每有一个Deferred被resolve，就减一，减到0时，所有的Deferred都被resolve了，就触发新建的Deferred的resolve。

        如果有Deferred被resolve，但remaining没有到0，就触发管理Deferred的notify
        */</span>
        updateFunc = <span class="function"><span class="keyword">function</span><span class="params">( i, contexts, values )</span> {</span>
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">( value )</span> {</span>
                contexts[ i ] = <span class="keyword">this</span>;
                values[ i ] = <span class="built_in">arguments</span>.length &gt; <span class="number">1</span> ? slice.call( <span class="built_in">arguments</span> ) : value;
                <span class="keyword">if</span> ( values === progressValues ) {
                    deferred.notifyWith( contexts, values );
                } <span class="keyword">else</span> <span class="keyword">if</span> ( !( --remaining ) ) {
                    deferred.resolveWith( contexts, values );
                }
            };
        },

        progressValues, progressContexts, resolveContexts;

    <span class="comment">/*为每个Deferred对象增加我们的更新函数，如果有reject，那么也触发管理Deferred的reject*/</span>
    <span class="keyword">if</span> ( length &gt; <span class="number">1</span> ) {
        progressValues = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        progressContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        resolveContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        <span class="keyword">for</span> ( ; i &lt; length; i++ ) {
            <span class="comment">/*这里只处理Deferred/Promise，其他不考虑*/</span>
            <span class="keyword">if</span> ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                resolveValues[ i ].promise()
                    .done( updateFunc( i, resolveContexts, resolveValues ) )
                    .fail( deferred.reject )
                    .progress( updateFunc( i, progressContexts, progressValues ) );
            } <span class="keyword">else</span> {
                --remaining;
            }
        }
    }

    <span class="comment">/*如果传入的参数都没有Deferred，直接resolve管理Deferred就好*/</span>
    <span class="keyword">if</span> ( !remaining ) {
        deferred.resolveWith( resolveContexts, resolveValues );
    }
    <span class="comment">/*将这个管理Deferred对象返回*/</span>
    <span class="keyword">return</span> deferred.promise();
}
</pre></td></tr></table></figure>


<p>从上面可以看到主要的实现思路就是，新建一个管理Deferred对象，它期望在参数中所有的Deferred被resolve后，执行自己的resolve操作。内部使用了一个计数器remaining，用于表明还有多少个Deferred尚未resolve。当这个计数器变成0时，所有的Deferred都被resolve了，那么这个管理Deferred也可以被resolve了。</p>
<p>为了维护这个计数器，在每个Deferred的done回调函数列表最后，绑定一个updateFunc函数，这个函数内部会修改remaining，以及判断是应该执行管理Deferred对象的resolve还是notify</p>
<p>而由于任何一个Deferred被reject的话，管理Deferred都会被reject，所以直接在每一个Deferred的fail回调函数列表上添加管理Deferred的reject方法就行了</p>
<p>另外需要注意一下参数中只有一个或没有Deferred的情况，前者可以省去创建管理Deferred对象，直接使用参数中的Deferred对象作为管理对象就行了。后者则可以直接执行resolve方法</p>
<h2 id="总结">总结</h2>
<p>jQuery中使用Deferred/Promise对象进行异步管理，其内部维护了三个Callbacks回调函数列表，这与常规的Promise的链式实现并不一致。在稍早的版本中，then方法其实也是和done、fail、progress一样往回调函数列表里添加方法，并不会形成Deferred链，后来Resig估计也发现了自己理解错了标准，于是乎通过pipe和then生成Deferred链，但这种Callbacks和Deferred链同时存在的方式，显得不伦不类，不过普通的需求基本上都能满足。jQuery的ready、ajax等都是使用Deferred/Promise来进行异步控制的</p>

      
    </div>
    <footer class="article-footer">
      
        <a href="http://hiservicerd.github.io/2014/05/17/jquery-source-promise/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery/">jQuery</a></li></ul>

      <div class="jiathis_style">
        <a class="jiathis_button_qzone"></a>
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_tqq"></a>
        <a class="jiathis_button_weixin"></a>
        <a class="jiathis_button_renren"></a>
        <a class="jiathis_button_xiaoyou"></a>
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <a class="jiathis_counter_style"></a>
      </div>
      <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1394026832027748" charset="utf-8"></script>
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术/">前端技术</a><span class="category-list-count">7</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/响应式/">响应式</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 20.00px;">CSS</a><a href="/tags/HTML/" style="font-size: 20.00px;">HTML</a><a href="/tags/JavaScript/" style="font-size: 15.00px;">JavaScript</a><a href="/tags/jQuery/" style="font-size: 10.00px;">jQuery</a><a href="/tags/响应式/" style="font-size: 10.00px;">响应式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05">五月 2014</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/">使用导航计时监测渲染关键路径</a>
          </li>
        
          <li>
            <a href="/2014/05/21/google-google-adding-interactivity-with-javaScript/">通过JavaScript增加交互性</a>
          </li>
        
          <li>
            <a href="/2014/05/21/google-render-blocking-css/">CSS的渲染阻塞</a>
          </li>
        
          <li>
            <a href="/2014/05/20/google-render-tree-construction-layout-and-paint/">渲染树的构建，布局和绘制</a>
          </li>
        
          <li>
            <a href="/2014/05/20/google-constructing-the-object-model/">构建对象模型</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 HiServiceRD<br>
      Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">文章</a>
  
    <a href="https://github.com/HiServiceRD" class="mobile-nav-link">GIT</a>
  
</nav>
    
<script>
  var disqus_shortname = 'hiservicerd';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript" src="/js/script.js"></script>
  </div>
</body>
</html>