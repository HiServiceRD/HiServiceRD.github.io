<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[海斯维思研发团队]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://hiservicerd.github.io/"/>
  <updated>2014-05-17T08:03:34.319Z</updated>
  <id>http://hiservicerd.github.io/</id>
  
  <author>
    <name><![CDATA[HiServiceRD]]></name>
    <email><![CDATA[lingyucoder@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[jQuery中的异步控制]]></title>
    <link href="http://hiservicerd.github.io/2014/05/17/jquery-source-promise/"/>
    <id>http://hiservicerd.github.io/2014/05/17/jquery-source-promise/</id>
    <published>2014-05-17T07:23:00.000Z</published>
    <updated>2014-05-17T07:44:16.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/jquery-source-promise/jQuery.jpg" alt="Write less, do more."></p>
<h2 id="简介">简介</h2>
<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>
<h2 id="jQuery-Callbacks">jQuery.Callbacks</h2>
<p>这是回调函数列表的构造器，内部使用一个数组来保存回调函数列表，并提供一系列的方法来维护这个列表。另外这个列表还有一些状态</p>
<h3 id="配置选项">配置选项</h3>
<p>创建一个回调函数列表可能会用到如下参数：</p>
<ol>
<li>options：一个选项类表，确定了回调函数列表如何工作，以及一些常见配置</li>
<li>once：默认情况下回调函数列表的执行时没有次数限制的，但如果设置了once，将设置回调函数列表只会被执行一次</li>
<li>memory：决定了在回调函数列表在执行过程中，是否会保留上一个函数执行的结果</li>
<li>unique：决定了回调函数列表中的函数能否重复</li>
<li>stopOnFalse：决定了在一个回调函数返回false后，后面的回调函数将不会被执行</li>
</ol>
<p>接下来看看构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>options = <span class="keyword">typeof</span> options === <span class="string">"string"</span> ?
    ( optionsCache[ options ] || createOptions( options ) ) :
    jQuery.extend( {}, options );
</pre></td></tr></table></figure>


<p>options可以是字符串，如<code>&quot;once memory&quot;</code>，如果是字符串，就先进行解析并缓存。如果options是对象，那么直接options就是这个对象</p>
<h3 id="私有变量">私有变量</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">var</span> <span class="comment">// Last fire value (for non-forgettable lists)</span>
    <span class="comment">/*用于存放运行结果*/</span>
    memory,
    <span class="comment">/*标志所有回调函数列表是否被触发过*/</span>
    fired,
    <span class="comment">/*标志当前正在执行回调函数列表中的函数*/</span>
    firing,
    <span class="comment">/*第一个被执行的回调函数*/</span>
    firingStart,
    <span class="comment">/*回调函数列表的长度*/</span>
    firingLength,
    <span class="comment">/*当前执行的回调函数在回调函数列表中的下标，如果移除了回调函数，将会对其进行修改*/</span>
    firingIndex,
    <span class="comment">/*保存回调函数的列表*/</span>
    list = [],
    <span class="comment">/*如果回调函数列表时多次执行的，那么在运行回调函数列表的过程中，可能会再次触发，这时候就需要一个队列进行等待了*/</span>
    stack = !options.once && [],
</pre></td></tr></table></figure>


<p>这里面都是一些私有变量，没啥太多好说的，官方代码里也对每个变量都写了注释</p>
<h3 id="触发函数fire">触发函数fire</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre>fire = <span class="function"><span class="keyword">function</span><span class="params">( data )</span> {</span>
    <span class="comment">/*如果使用了memory配置，data会先被保存在memory中*/</span>
    memory = options.memory && data;
    <span class="comment">/*表明这个回调函数列表已经被触发过了*/</span>
    fired = <span class="literal">true</span>;
    <span class="comment">/*确定当前执行的回调函数在回调函数列表中的位置*/</span>
    firingIndex = firingStart || <span class="number">0</span>;
    <span class="comment">/*将起始设为0*/</span>
    firingStart = <span class="number">0</span>;
    <span class="comment">/*获取回调函数列表的总长度*/</span>
    firingLength = list.length;
    <span class="comment">/*修改状态为正在执行*/</span>
    firing = <span class="literal">true</span>;
    <span class="comment">/*依次执行回调函数*/</span>
    <span class="keyword">for</span> ( ; list && firingIndex &lt; firingLength; firingIndex++ ) {
        <span class="comment">/*如果回调函数返回值是false且设定了stopOnFalse，那么执行结束，memory清空*/</span>
        <span class="keyword">if</span> ( list[ firingIndex ].apply( data[ <span class="number">0</span> ], data[ <span class="number">1</span> ] ) === <span class="literal">false</span> && options.stopOnFalse ) {
            memory = <span class="literal">false</span>; <span class="comment">// To prevent further calls using add</span>
            <span class="keyword">break</span>;
        }
    }
    <span class="comment">/*修改正在执行状态为false*/</span>
    firing = <span class="literal">false</span>;
    
    <span class="comment">/*如果等待队列中有数据，那么需要获取等待队列中的数据，再次执行回调函数列表*/</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">/*多次执行的话，stack是个数组*/</span>
        <span class="keyword">if</span> ( stack ) {
            <span class="comment">/*从等待队列中弹出数据再次执行*/</span>
            <span class="keyword">if</span> ( stack.length ) {
                fire( stack.shift() );
            }
        <span class="comment">/*如果是单次执行，且所有函数正常执行完成，缓存了最终结果，清空回调函数列表*/</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) {
            list = [];
        <span class="comment">/*否则说明函数没有正常执行完成，将回调函数列表设为无效*/</span>
        } <span class="keyword">else</span> {
            self.disable();
        }
    }
},
</pre></td></tr></table></figure>


<p>这里可以看到触发回调函数列表的逻辑。触发后，会依次执行列表中的回调函数，这里执行时有一个stopOnFalse设置，如果函数返回false，那么就终止执行。另外在执行过程中，如果又有新的执行请求到来，需要将执行请求放入等待队列之中，等待当前执行中的所有回调函数完成之后再重新执行。当然这个设定对once类型的回调函数列表不起作用</p>
<h3 id="实例">实例</h3>
<p>接下来创建了一个self对象，并进行了返回，这是个一个构造函数，说明self是真正返回的实例。看看实例中有哪些方法：</p>
<h4 id="add">add</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre>add: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">//首先保存当前列表长度</span>
        <span class="keyword">var</span> start = list.length;
        <span class="comment">/*使用jQuery.each方法遍历深度遍历arguments：
        1. 如果键值对中值为函数，那么直接添加，需要注意的是如果有unique选项，在添加前需要判重
        2. 如果值为对象那么遍历这个对象进行添加 */</span>
        (<span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">( args )</span> {</span>
            jQuery.each( args, <span class="function"><span class="keyword">function</span><span class="params">( _, arg )</span> {</span>
                <span class="keyword">var</span> type = jQuery.type( arg );
                <span class="keyword">if</span> ( type === <span class="string">"function"</span> ) {
                    <span class="keyword">if</span> ( !options.unique || !self.has( arg ) ) {
                    list.push( arg );
                    }
                } <span class="keyword">else</span> <span class="keyword">if</span> ( arg && arg.length && type !== <span class="string">"string"</span> ) {
                    <span class="comment">// Inspect recursively</span>
                    add( arg );
                }
            });
        })( <span class="built_in">arguments</span> );
        <span class="comment">/*如果正在执行回调函数列表，那么需要维护一下长度*/</span>
        <span class="keyword">if</span> ( firing ) {
            firingLength = list.length;
        <span class="comment">/*如果memory中已经有值，执行所有新增加的回调函数*/</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) {
            firingStart = start;
            fire( memory );
        }
    }
    <span class="comment">/*返回this方便链式操作*/</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>这个方法往回调函数列表中添加新函数，jQuery会非常智能的使用each对参数进行深度遍历来添加所有函数。需要注意的是，如果回调函数列表正在执行，添加之后需要维护长度。另外如果memory中有数据，我们就应该立即执行新添加的回调函数</p>
<h4 id="remove">remove</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>remove: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">/*遍历arguments，对每个函数分执行删除操作*/</span>
        jQuery.each( <span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span><span class="params">( _, arg )</span> {</span>
            <span class="keyword">var</span> index;
            <span class="comment">/*通过jQuery.inArray获取函数在回调函数列表中的位置*/</span>
            <span class="keyword">while</span> ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -<span class="number">1</span> ) {
                <span class="comment">/*删除掉这个函数*/</span>
                list.splice( index, <span class="number">1</span> );
                <span class="comment">/*如果正在执行回调函数，需要维护长度和当前正在执行的回调函数的下标*/</span>
                <span class="keyword">if</span> ( firing ) {
                    <span class="keyword">if</span> ( index &lt;= firingLength ) {
                        firingLength--;
                    }
                    <span class="keyword">if</span> ( index &lt;= firingIndex ) {
                        firingIndex--;
                    }
                }
            }
        });
    }
    <span class="comment">/*返回this方便链式操作*/</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>这里同样使用<code>jQuery.each</code>遍历所有参数，获取其中的函数，通过inArray判定，然后通过splice移除。这里需要注意的是，在回调函数列表正在执行时，删除操作同样需要维护长度，另外还可能需要维护当前正在运行的函数的下标</p>
<h4 id="has_(fn)">has (fn)</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>has: <span class="function"><span class="keyword">function</span><span class="params">( fn )</span> {</span>
    <span class="keyword">return</span> fn ? jQuery.inArray( fn, list ) &gt; -<span class="number">1</span> : !!( list && list.length );
},
</pre></td></tr></table></figure>


<p>判断一个函数是否在回调函数列表中，分判断函数和判断列表两种情况：</p>
<ol>
<li>若有fn，直接用inArray判定</li>
<li>若无fn，直接判断列表是否有长度不为0的list列表</li>
</ol>
<h4 id="empty">empty</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>empty: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    list = [];
    firingLength = <span class="number">0</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>清空回调函数列表，没啥好说的…list社为空数组，长度设为0</p>
<h4 id="disable和disabled">disable和disabled</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>disabled: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    list = stack = memory = <span class="literal">undefined</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
disabled: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !list;
},
</pre></td></tr></table></figure>


<p>将回调函数列表设定为无效，实际上就是将list，stack，memory设成undefined，检测无效也很简单，直接通过list判断，没设定无效情况下，list都是数组，其必然是真值</p>
<h4 id="lock和locked">lock和locked</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>lock: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    stack = <span class="literal">undefined</span>;
    <span class="keyword">if</span> ( !memory ) {
        self.disable();
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
locked: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !stack;
},
</pre></td></tr></table></figure>


<p>lock和locked故名思意就是将回调函数列表锁住，其判定方式是stack是否存在，在once设置下，stack本来就不存在，直接就是locked。而非once情况下，lock函数会设定stack为undefined，这样就无法在回调函数运行时进行fire了，就算锁住了。另外，如果没有memory，说明回调函数执行失败了，直接disbale掉就好</p>
<h4 id="fireWith和fire">fireWith和fire</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>fireWith: <span class="function"><span class="keyword">function</span><span class="params">( context, args )</span> {</span>
    <span class="comment">/*如果回调函数列表还有效，没触发过或者可以多次触发，那么就满足触发条件了*/</span>
    <span class="keyword">if</span> ( list && ( !fired || stack ) ) {
        args = args || [];
        args = [ context, args.slice ? args.slice() : args ];
        <span class="comment">/*如果正在出发，就放到等待队列中*/</span>
        <span class="comment">/*如果once且触发过或正在触发，可以从私有方法fire中看到，fired是在方法一开始被设置的，所以无法通过上面的fired条件，能到这里必然是没有触发或多次触发的情况。而没有触发不存在firing状态，也就不需要检测stack了*/</span>
        <span class="keyword">if</span> ( firing ) {
            stack.push( args );
        <span class="comment">/*否则直接触发*/</span>
        } <span class="keyword">else</span> {
            fire( args );
        }
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
fire: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    self.fireWith( <span class="keyword">this</span>, <span class="built_in">arguments</span> );
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
fired: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !!fired;
}
</pre></td></tr></table></figure>


<p>这里fire实际上使用fireWith实现的，我们只需要看fireWith就好。这里fireWith将触发回调函数列表的执行，触发条件是：当前回调函数列表有效，且没触发过或可以多次触发（stack存在就是可以多次触发），需要注意的是，如果正在触发，也就是firing状态时，触发请求将会被放入stack中等待</p>
<p>fired没啥好说的，判断回调函数列表是否被触发过</p>
<h3 id="小结">小结</h3>
<p>这个<code>jQuery.Callbacks</code>本质上就是维护一个数组，这个数组中都是函数。一个特点就是可以通过fire方式去挨个执行这些函数，并提供了一些配置来确定执行的过程以及执行的次数。每个Deferred对象将拥有三个Callbacks实例</p>
<h2 id="Deferred">Deferred</h2>
<p>jQuery的异步控制使用Deferred/Promise，每一个Deferred对象对应一个Promise对象，首先来看看其构造函数</p>
<h3 id="构造函数">构造函数</h3>
<h4 id="三个状态，三个操作，三个列表">三个状态，三个操作，三个列表</h4>
<p>Deferred有三个状态：</p>
<ol>
<li>pending</li>
<li>resolved</li>
<li>rejected</li>
</ol>
<p>pending状态是最初状态，它等待resolve操作或reject操作，使用resolve操作表示成功，将跳转到resolved状态，而使用reject将跳转到rejected状态，这两个转变是不可逆的。另外在pending状态下可以无限次调用notify操作</p>
<p>事实上，每个操作对应着一系列的回调函数，看一下定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> tuples = [
    [ <span class="string">"resolve"</span>, <span class="string">"done"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"resolved"</span> ],
    [ <span class="string">"reject"</span>, <span class="string">"fail"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"rejected"</span> ],
    [ <span class="string">"notify"</span>, <span class="string">"progress"</span>, jQuery.Callbacks(<span class="string">"memory"</span>) ]
],
</pre></td></tr></table></figure>


<p>可以看到，这里为resolve、reject、notify这三个操作分别创建了Callbakcs的实例。这里为三个操作的具体定义如下：</p>
<ol>
<li>resolve方法，对应的添加回调函数的方法是done，回调函数列表类型是once和memory，运行后状态转变到resolved</li>
<li>reject方法，对应的添加回调函数的方法是fail，回调函数列表类型是once和memory，运行后状态转变到rejected</li>
<li>notify方法，对应的添加回调函数的方法为progress，回调函数列表类型是memory，说明可执行多次，执行后不会转变状态</li>
</ol>
<p>构造函数下面，会为每一个操作在Promise对象和Deferred对象上生成对应的函数（Promise上是：done、fail、progress。Deferred上是：resolve、reject、notify）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="comment">/*针对三个操作分别进行加工*/</span>
jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
    <span class="comment">/*获取操作的回调函数列表*/</span>
    <span class="keyword">var</span> list = tuple[ <span class="number">2</span> ],
        <span class="comment">/*获取操作执行后的状态*/</span>
        stateString = tuple[ <span class="number">3</span> ];

    <span class="comment">// promise[ done | fail | progress ] = list.add</span>
    <span class="comment">/*为promise对象分别生成done、fail、progress方法，直接映射到对应的回调函数列表对象的add添加方法*/</span>
    promise[ tuple[<span class="number">1</span>] ] = list.add;

    <span class="comment">// Handle state</span>
    <span class="comment">/* 如果状态会改变，说明是resolve方法或reject方法，由于状态转变不可逆，所以需要在回调函数列表最后添加三个函数，分别用于状态修改、使回调函数列表无效、将回调函数列表锁住*/</span>
    <span class="keyword">if</span> ( stateString ) {
        list.add(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="comment">// state = [ resolved | rejected ]</span>
            state = stateString;

        <span class="comment">// [ reject_list | resolve_list ].disable; progress_list.lock</span>
        }, tuples[ i ^ <span class="number">1</span> ][ <span class="number">2</span> ].disable, tuples[ <span class="number">2</span> ][ <span class="number">2</span> ].lock );
    }
    
    <span class="comment">// deferred[ resolve | reject | notify ]</span>
    <span class="comment">/*在deferred上添加resolve、reject、notify方法，分别映射到其回调函数列表的fireWith上*/</span>
    deferred[ tuple[<span class="number">0</span>] ] = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === deferred ? promise : <span class="keyword">this</span>, <span class="built_in">arguments</span> );
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*为deferred对象添加resolveWith，rejectWith，notifyWith，对应的回调函数列表的fireWith*/</span>
    deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ] = list.fireWith;
});
</pre></td></tr></table></figure>


<p>上面的三种操作，只是定义了名称，这里才是真正生成对应函数的地方。jq会为每个Deferred对象生成6个方法：</p>
<ol>
<li>resolve</li>
<li>reject</li>
<li>notify</li>
<li>resolveWith</li>
<li>rejectWith</li>
<li>notifyWith</li>
</ol>
<p>上面三个实际上是直接调用下面三个，只不过加了个默认的参数。下面三个实际上就是对应回调函数列表的fireWith方法。</p>
<p>同时，这里还会为promise增加三个方法：</p>
<ol>
<li>done</li>
<li>fail</li>
<li>progress</li>
</ol>
<p>这三个方法就是为对应的回调函数列表添加新函数的方法，直接映射到对应回调函数列表的add方法就行了</p>
<p>另外需要注意一下resolve和reject方法的一次性，实际上也就是在回调函数列表最后加上disable和lock方法</p>
<h3 id="promise对象">promise对象</h3>
<p>上面反复说了Promise对象，来看看Promise对象的真正面貌：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>promise = {
    <span class="comment">/*获得当前状态的方法*/</span>
    state: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> state;
    },
    <span class="comment">/*无论执行成功与否，都执行参数中的回调*/</span>
    always: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        deferred.done( <span class="built_in">arguments</span> ).fail( <span class="built_in">arguments</span> );
        <span class="keyword">return</span> <span class="keyword">this</span>;
    },
    <span class="comment">/*顺序声明三个函数，分别在成功，失败，执行中时进行调用，返回一个promise对象*/</span>
    then: <span class="function"><span class="keyword">function</span><span class="params">( <span class="comment">/* fnDone, fnFail, fnProgress */</span> )</span> {</span>
        <span class="comment">/*then的代码*/</span>
    },
    <span class="comment">// Get a promise for this deferred</span>
    <span class="comment">// If obj is provided, the promise aspect is added to the object</span>
    <span class="comment">/*获取promise对象*/</span>
    promise: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> {</span>
        <span class="keyword">return</span> obj != <span class="literal">null</span> ? jQuery.extend( obj, promise ) : promise;
    }
},
deferred = {};
<span class="comment">/*pipe方法，实际上就是then，为了符合标准罢了*/</span>
promise.pipe = promise.then;
<span class="comment">/*这里为Promise添加了done、fail、progress方法*/</span>
<span class="comment">/*这里为Deferred添加了resolve、resolveWith、reject、rejectWith、notify、notifyWith方法*/</span>
jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
    <span class="comment">/*上面的代码*/</span>
});
<span class="comment">/*将Promise对象的所有方法拷贝给Deferred对象*/</span>
promise.promise( deferred );
</pre></td></tr></table></figure>


<p>这里可以看到，promise对象提供了几个接口：</p>
<ol>
<li>state：获取当前Deferred对象的状态</li>
<li>always：欧诺更是使用done和fail，使得参数中的方法在deferred成功和失败时都执行</li>
<li>then：使用done、fail、progress分别绑定函数，代码较多，后面再讲</li>
<li>promise：如果对象存在，向一个对象添加promise对象中的接口，否则直接返回promise对象</li>
<li>pipe：就是then，别名而已</li>
<li>done，fail，progress：上面介绍过，不赘述了</li>
</ol>
<h4 id="Promise和Deferred的区别">Promise和Deferred的区别</h4>
<p>这里在申明了promise对象之后，在Deferred对象中添加了promise所有的方法。另外Deferred对象拥有之前说的resolve等6个方法，Deferred对象和Promise对象的区别就很明显了：Promise实际上就是没有resolve、resolveWith、reject、rejectWith、notify、notifyWith这六个方法，其他和Deferred对象一样</p>
<h4 id="then和pipe">then和pipe</h4>
<p>上面略过了then方法，这里单独拉出来说一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>then: <span class="function"><span class="keyword">function</span><span class="params">( <span class="comment">/* fnDone, fnFail, fnProgress */</span> )</span> {</span>
    <span class="keyword">var</span> fns = <span class="built_in">arguments</span>;
    <span class="comment">/*这里新建了一个Deferred对象，并返回其Promise对象，以构成一个Deferred对象链
    由于这里返回的是Promise对象，没有resolve等方法，所以触发必须在整个Deferred对象链的头上触发
    链上的每个Deferred对象的三个回调函数列表的最后，都会有一个函数，用于触发链的下一个Deferred对象的相对应的回调函数列表
    */</span>
    <span class="keyword">return</span> jQuery.Deferred(<span class="function"><span class="keyword">function</span><span class="params">( newDefer )</span> {</span>
        <span class="comment">/*对于上面三种，分别将函数加入到对应的回调函数列表中*/</span>
        jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
            <span class="keyword">var</span> fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
            <span class="comment">/*向当前Deferred最后添加一个函数，用于触发链的下一个Deferred对象的相关回调函数列表*/</span>
            deferred[ tuple[<span class="number">1</span>] ](<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                <span class="keyword">var</span> returned = fn && fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );
                <span class="comment">/*如果返回值是Deferred对象，获取其Promise对象，并为其绑定相关触发操作*/</span>
                <span class="keyword">if</span> ( returned && jQuery.isFunction( returned.promise ) ) {
                    returned.promise()
                        .done( newDefer.resolve )
                        .fail( newDefer.reject )
                        .progress( newDefer.notify );
                <span class="comment">/*如果不是Deferred对象，直接在新建的deferred对象上添加相关触发操作*/</span>
                } <span class="keyword">else</span> {
                    newDefer[ tuple[ <span class="number">0</span> ] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === promise ? newDefer.promise() : <span class="keyword">this</span>, fn ? [ returned ] : <span class="built_in">arguments</span> );
                }
            });
        });
        fns = <span class="literal">null</span>;
    }).promise();
},
</pre></td></tr></table></figure>


<p>这个函数是Deferred的一个非常重要的函数，它实现了一个Deferred链。这个Deferred链的特点是，只有链的头节点是Deferred对象，后面都是Promise对象，这也意味着，只能在头节点触发resolve、reject、notify操作。触发了操作之后，对应的操作会顺着链传递下去，触发了一个节点resolve，执行完毕后，会自动触发下一个节点的resolve，reject和notify同理。</p>
<p>这里传入的三个函数会分别在当前的Deferred相关操作被触发时执行，如果执行返回的是一个Deferred/Promise对象，获取其Promise对象，新建的Deferred对象将会被链在这个返回的Deferred对象之后。如果返回其他的值，新建的Deferred对象的resolveWith、rejectWith、notifyWith方法会被直接触发，达到链式的效果。</p>
<h3 id="小结-1">小结</h3>
<p>这就是jQuery的Deferred/Promise的全貌了。Promise对象实际上是Deferred对象的除去resolve等6个方法的子集。done、fail、progress分别对应一个回调函数列表，这三个方法实际上就是往对应的回调函数列表中插入函数。但then和pipe不相同，它们会新建一个Deferred对象，并构造一个Deferred对象链。这也让jQuery的Deferred/Promise显得不论不类。</p>
<h2 id="when">when</h2>
<p>when方法提供了将多个Deferred对象聚集的能力，在when方法中传入一些Deferred对象，返回一个Deferred对象。在参数中的所有Deferred对象都被resolve之后，会resolve这个返回的Deferred对象，如果参数中的Deferred有一个被reject了，那么这个返回的Deferred也会被reject。另外，在参数中的Deferred对象resolve时，返沪ideDeferred也会被notify。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre>when: <span class="function"><span class="keyword">function</span><span class="params">( subordinate <span class="comment">/* , ..., subordinateN */</span> )</span> {</span>
    <span class="keyword">var</span> i = <span class="number">0</span>,
        <span class="comment">/*切分参数到数组*/</span>
        resolveValues = slice.call( <span class="built_in">arguments</span> ),
        <span class="comment">/*数组长度*/</span>
        length = resolveValues.length,

        <span class="comment">/* 未完成的需要监听的Deferred对象的个数 */</span>
        remaining = length !== <span class="number">1</span> || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : <span class="number">0</span>,
        <span class="comment">/*新建一个Deferred对象用于管理所有的Deferred对象结果，*不妨就叫管理Deferred吧，如果参数只有一个Deferred，就不需要新建了，直接用它就行了/
        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

        /*
        使用一个计数器来计算的，计数器就是remaining，初始为需要执行的Deferred对象的个数，每有一个Deferred被resolve，就减一，减到0时，所有的Deferred都被resolve了，就触发新建的Deferred的resolve。

        如果有Deferred被resolve，但remaining没有到0，就触发管理Deferred的notify
        */</span>
        updateFunc = <span class="function"><span class="keyword">function</span><span class="params">( i, contexts, values )</span> {</span>
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">( value )</span> {</span>
                contexts[ i ] = <span class="keyword">this</span>;
                values[ i ] = <span class="built_in">arguments</span>.length &gt; <span class="number">1</span> ? slice.call( <span class="built_in">arguments</span> ) : value;
                <span class="keyword">if</span> ( values === progressValues ) {
                    deferred.notifyWith( contexts, values );
                } <span class="keyword">else</span> <span class="keyword">if</span> ( !( --remaining ) ) {
                    deferred.resolveWith( contexts, values );
                }
            };
        },

        progressValues, progressContexts, resolveContexts;

    <span class="comment">/*为每个Deferred对象增加我们的更新函数，如果有reject，那么也触发管理Deferred的reject*/</span>
    <span class="keyword">if</span> ( length &gt; <span class="number">1</span> ) {
        progressValues = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        progressContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        resolveContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        <span class="keyword">for</span> ( ; i &lt; length; i++ ) {
            <span class="comment">/*这里只处理Deferred/Promise，其他不考虑*/</span>
            <span class="keyword">if</span> ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                resolveValues[ i ].promise()
                    .done( updateFunc( i, resolveContexts, resolveValues ) )
                    .fail( deferred.reject )
                    .progress( updateFunc( i, progressContexts, progressValues ) );
            } <span class="keyword">else</span> {
                --remaining;
            }
        }
    }

    <span class="comment">/*如果传入的参数都没有Deferred，直接resolve管理Deferred就好*/</span>
    <span class="keyword">if</span> ( !remaining ) {
        deferred.resolveWith( resolveContexts, resolveValues );
    }
    <span class="comment">/*将这个管理Deferred对象返回*/</span>
    <span class="keyword">return</span> deferred.promise();
}
</pre></td></tr></table></figure>


<p>从上面可以看到主要的实现思路就是，新建一个管理Deferred对象，它期望在参数中所有的Deferred被resolve后，执行自己的resolve操作。内部使用了一个计数器remaining，用于表明还有多少个Deferred尚未resolve。当这个计数器变成0时，所有的Deferred都被resolve了，那么这个管理Deferred也可以被resolve了。</p>
<p>为了维护这个计数器，在每个Deferred的done回调函数列表最后，绑定一个updateFunc函数，这个函数内部会修改remaining，以及判断是应该执行管理Deferred对象的resolve还是notify</p>
<p>而由于任何一个Deferred被reject的话，管理Deferred都会被reject，所以直接在每一个Deferred的fail回调函数列表上添加管理Deferred的reject方法就行了</p>
<p>另外需要注意一下参数中只有一个或没有Deferred的情况，前者可以省去创建管理Deferred对象，直接使用参数中的Deferred对象作为管理对象就行了。后者则可以直接执行resolve方法</p>
<h2 id="总结">总结</h2>
<p>jQuery中使用Deferred/Promise对象进行异步管理，其内部维护了三个Callbacks回调函数列表，这与常规的Promise的链式实现并不一致。在稍早的版本中，then方法其实也是和done、fail、progress一样往回调函数列表里添加方法，并不会形成Deferred链，后来Resig估计也发现了自己理解错了标准，于是乎通过pipe和then生成Deferred链，但这种Callbacks和Deferred链同时存在的方式，显得不伦不类，不过普通的需求基本上都能满足。jQuery的ready、ajax等都是使用Deferred/Promise来进行异步控制的</p>
]]></content>
    
    
      <category term="JavaScript" scheme="http://hiservicerd.github.io/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="http://hiservicerd.github.io/tags/jQuery/"/>
    
      <category term="前端技术" scheme="http://hiservicerd.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我们是海斯维思研发团队]]></title>
    <link href="http://hiservicerd.github.io/2014/05/13/who-are-we/"/>
    <id>http://hiservicerd.github.io/2014/05/13/who-are-we/</id>
    <published>2014-05-13T15:48:01.000Z</published>
    <updated>2014-05-14T08:18:54.000Z</updated>
    <content type="html"><![CDATA[<p>北京海斯维思信息科技有限公司是一家提供IT综合服务的高科技企业，业务涵盖：IT产品化服务、应用软件开发、系统集成等。一直以为中国中、小企业提升IT核心竞争力为使命，以坚实的技术实力、对客户业务的良好理解以及高效的实施队伍，为行业客户、企业集团提供面向业务的解决方案、定制化和产品化的专业IT服务。而我们，是海斯维思信息科技有限公司的研发团队</p>
]]></content>
    
    
  </entry>
  
</feed>
